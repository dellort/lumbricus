module wwptools.untile;

import framework.imgwrite;
import framework.surface;
import wwptools.image;
import utils.stream;
import utils.configfile;
import utils.filetools;
import utils.misc;
import utils.vector2;

import tango.io.FilePath;
import tango.io.vfs.model.Vfs;

import tango.io.model.IFile : FileConst;
const pathsep = FileConst.PathSeparatorChar;

///Params:
///  filename = full path to input image
///  destPath = output directory with trailing separator (has to exist)
///  imgPath = relative directory for images (no separators)
///  nameHead = Prefix for image names
///  nameTail = Suffix for image names
///  confName = filename for config file (without path), if empty no config
///             file is written
///  namefile = stream where image names are read from (one name per line,
///             can be null)
///in-memory-version:
///  img = instead of filename
///  filename = to get the name of the thing (filename is never opened or so)
void do_untile(char[] filename, VfsFolder destFolder, char[] imgPath,
    char[] nameHead, char[] nameTail, char[] confName, Stream namefile)
{
    scope auto img = loadImageFromFile(filename);
    do_untile(img, filename, destFolder, imgPath, nameHead, nameTail, confName,
        namefile);
}
void do_untile(Surface img, char[] filename, VfsFolder destFolder, char[] imgPath,
    char[] nameHead, char[] nameTail, char[] confName, Stream namefile)
{
    //hey there; scope doesn't work on arrays
    scope buffer = new void[2*1024*1024];
    char[] fnbase = FilePath(filename).name;
    //path.getBaseName(path.getName(filename));

    char[][] names = str.splitlines(cast(char[])namefile.readAll());

    ConfigNode conffile, bmps;
    if (confName.length) {
        conffile = new ConfigNode();
        auto s = conffile.getSubNode("resources");
        s.comment = "//Automatically generated by untile";
        bmps = s.getSubNode("bitmaps");
    }

    auto imgFolder = destFolder;
    if (imgPath.length > 0)
        imgFolder = destFolder.folder(imgPath).create;

    int sNameIdx = 0;
    char[] getNextName() {
        if (names.length) {
            return nameHead ~ names[sNameIdx++] ~ nameTail;
        } else {
            return nameHead ~ fnbase ~ nameTail ~ myformat("{}", sNameIdx++);
        }
    }

    void saveImg(Surface imgToSave) {
        char[] baseName = getNextName();
        auto f = imgFolder.file(baseName ~ ".png").create.output;
        scope(exit) f.close();
        //xxx assumes png
        saveImage(imgToSave, new ConduitStream(f));
        if (conffile) {
            bmps.setStringValue(baseName, imgPath ~ "/" ~ baseName ~ ".png");
        }
    }

    if (img.size.y > img.size.x) {
        int tilesize = img.size.x;
        for (int i = 0; i < img.size.y/tilesize; i ++) {
            auto s = Vector2i(tilesize);
            auto imgout = new Surface(s);
            imgout.copyFrom(img, Vector2i(0), Vector2i(0, tilesize*i), s);
            saveImg(imgout);
        }
    } else {
        int tilesize = img.size.y;
        for (int i = 0; i < img.size.x/tilesize; i ++) {
            auto s = Vector2i(tilesize);
            auto imgout = new Surface(s);
            imgout.copyFrom(img, Vector2i(0), Vector2i(tilesize*i, 0), s);
            saveImg(imgout);
        }
    }

    if (conffile) {
        auto outp = destFolder.file(confName).create.output;
        scope(exit) outp.close();
        conffile.writeFile((new ConduitStream(outp)).pipeOut());
    }
}
