! PITA (hacks entfernen/neuschreiben, kompliziert, wenig gewinn),
- Fix/Change,
+ kleines Feature,
* großes, langfristiges Feature,
*** völlig unmöglich,
[] wurde versucht, aber nur kompromiss wurde implementiert oder es hat nicht geklappt
$ sollte behoben sein / works for me (muss getestet werden)

== Sonstiges/Minor ==
+ editor/debug modus: spielzeit läuft nicht ab, untersuchung/platzierung von game objekten
$ weapon cooldown: wenn feuer-taste nichts tut, rauchwolke vom wurm aufsteigen lassen?
  ^ es gibt jetzt ein Waffensymbol das rot blinkt bei Cooldown, reicht das?
  ^ hm ja, besser als keine Reaktion
- animation für kranke würmer benutzen
  ^ es gibt schon eine lowhp_animation, die auch ihren Sinn in WWP hat; mir ist nicht ganz klar wann genau die Animation für kranke Würmer stattdessen angezeigt werden soll (nur wenn der Wurm vergifted wurde? das hab ich implementiert)
- lua console: the in-game lua one can't do anything when the game is paused
- parameter handling von ComplicatedAnimation mit dem von AnimEffect vereinen? ja/nein
- Bohrer/Lötlampe stoßen Würmer weg: verbessern (mehr impuls, weniger schaden?)
- axt abfeuern + sofort bazooka auswählen => falsche zielkreuz animation
- entscheiden, ob Lua Full-Userdata verwendet werden soll, und dann die Entscheidung konsequent durchsetzen (z.B. keine globalen Class_method Funktionen mehr)
  im Moment geht noch beides; vielleicht sollte man erst Performance-Tests durchführen? (bloss welche...)
- jetpack einschalten, homing missile auswählen, feuertaste drücken (ohne ziel auszuwählen, d.h. es wird nichts abgefeuert), bazooka auswählen => bazooka wird abgefeuert, obwohl man sie nur ausgewählt hat
  ^ Kann ich nicht reproduzieren
- settings sollten nicht bei jedem window resize gespeichert werden, sondern in einem settings dialog?
  wenn man wollte, könnte man settings2.conf auch nach _irgendeiner_ änderung speichern

== bekannte, lösbare Bugs ==
- Napalm verursacht zuviel Schaden (durch neuen Explosionscode; wenn man einfach den
  Schaden reduziert werden die Löcher zu klein)
  Genauso: Minigun macht zuviel Schaden (bis 350 für die volle Ladung)
  ^ Idee: Nichtlineare Funktion für die Lochgröße (nur welche?)
    ^^ kann man nicht einfach den Schaden->Lochgröße Multiplikator erhöhen

== bekannte, unlösbare Bugs ==
- physik mehr wie wwp (z.b. wenn ein wurm nach unten fällt, bleibt er in wwp im boden stecken, zieht sich raus, und bleibt sitzen, während er in lumbricus wie ein gummiball abprallt)
- Projektil fliegt durch wenige Pixel dicke Landschaft, wenn der Wurm beim Feuern direkt davorsteht
- wurm laufen auf objekten (statt landschaft) ist kaputt
- physik: "kleben" verbessern, v.a. sollte es möglich sein, dass würmer über andere würmer laufen und wurmtürme gebaut werden können (wie in WWP)
  idee: features aus rigid-body physic engines klauen und box stacking möglich machen (z.b. chipmunk); dazu bräuchte man aber trotzdem noch "kleben", was chipmunk nicht hat
  idee fürs "kleben":
  - objekt bewegt sich nicht mehr, wenn die geschwindigkeit 0 ist und alle kräfte, die auf das objekt wirken sich aufheben
  - alle kräfte = 0 ist gleichbedeutend mit es gibt keine geschwindigkeitsänderung
  - geschwindigkeitsänderung ist alles, was auf die geschwindigkeit addiert wird (gravitation, kräfte, impulse durch constraints und kollisionen)
  - kollisionen mit dem boden lösen impulse aus, die die gravitation aufheben (in der theorie), eventuell muss man mit speziellem code nachhelfen um die gegenkraft permanent aufrechtzuerhalten, oder z.b. leichtes eindringen der objekte in den boden erlauben
  (bin mit meinen amateurhaften versuchen soweit gescheitert)
- Zuständigkeit von globaler und Chatbox-Konsole überarbeiten (i.V. mit dem mysteriösen "server"-Befehl)
  (evtl. einfach den "server"-Befehl entfernen und die Chatbox-Konsole nur "server"-Kommandos ausführen lassen; könnte andererseits auch gewaltige Engine-Änderungen benötigen)
  ^ wie genau?
    die globale Konsole und die Chatbox sind jetzt praktisch gleich
- wurm, der im napalm kocht, zeigt manchmal animation für unkontrollierten/schnellen fall an (sollte sein: rutsch animation)
- net server sollte nicht 100% CPU benutzen
    zur zeit wird alles gepollt: enet, broadcast sockets (announce zeug), timeouts...
    schwierigkeit: man muss alles gleichzeitig im blockierenden modus irgendwie gut zusammenarbeiten lassen
    ausserdem, was ist denn checkPacketPreview() für eine katastrophe? macht es sicher unmöglich, enet blockierend einzusetzen
  ^ a) Ich weiß ja nicht was da unter Linux schiefläuft, aber unter Windows braucht
       der Server dank yield() ca. 0% CPU
       ^^ der Unterschied ist wahrscheinlich, dass yield unter Windows den Thread in den Wartezustand versetzt (und dieser vllt. ein Timeslice lang schläft?), während er in Linux nur ein Rescheduling verursacht, d.h. wenn kein anderer Prozess im System aktiv ist, macht yield nichts. Der Server wird anderen Prozessen keine CPU-Zeit weggnehmen, aber es wird trotzdem 100% Belastung angezeigt (und die CPU heizt sich auf).
    b) Nicht wirklich, man müsste halt checkPacketPreview() und nicht enet blockierend machen;
       aber natürlich ist checkPacketPreview() ein dreckiger hack; ein callback aus enet
       (onRawReceive oder so) wäre da wesentlich schöner, nur den gibts halt nicht;
       btw: checkPacketPreview dient hauptsächlich dazu die raw-pakete vor enet zu inspizieren
            und weniger, die pakete von enet fernzuhalten; ich weiß halt nicht wie enet auf
            protokollverletzungen reagiert
    c) Ein blockierender Server müsste zwangsläufig mehrere Threads verwenden (regelmäßig
       ausgehende Timestamp-Pakete + warten auf eingehende Pakete); also ich hab keine Lust das
       zu implementieren
       ^^ ich auch nicht, deshalb ist es ja auch unter "unlösbar".... das Blöde dabei ist, ein zentrales select() könnte sich um alles kümmern (inklusive Timeouts), also bräuchte man eigentlich keine extra Threads. man müsste halt alle verwendeten Sockets kennen, vor allem enets.

== Performance Bugs, "Dinge die nicht so weiter gehen können", etc. ==
- GUI zeichnet hintergrund bild selbst wenn komplett verdeckt (z.b. während des spiels) (ähnliches problem gibt es mit löschung des hintergrund: z.b. fensterhintergrund sollte nicht gelöscht werden, wenn das spiel das eh tut, vor allem im vollbildmodus; dazu gibt es zur zeit ekligen spezialcode)

== GUI (allgemeine Features) ==
+ key bindings editor
[*** GUI enthässlichen]
*** GUI durch was einfacheres ersetzen
    idee:
    - einfaches, skaliertes gitter (GUI wird auf höhe des SDL fensters skaliert, unter beibehaltung des aspect ratio)
    - GUI elemente werden explizit platziert (kein rekursives layout zeug wie BoxContainer etc.) => einfacher
    - inhalte (schriften, bitmaps, ränder) werden ebenfalls skaliert
    - QT4 designer produziert XML => könnte man ausnutzen? (positionieren von elementen etc.; Inkscape/SVG wäre eine weitere möglichkeit)
vllt: http://tekui.teklib.org/index.html
        hauptsächlich in Lua implementiert, kleine C-teile, kleines backend interface (läuft z.b. auf framebuffer), sieht potthässlich aus

== GUI spielspezifisch (Dialoge) ==
* Netzwerk-GUI (Spielerliste, Scores, Chat, Ping/Lag/Warte-auf-Server)
+ Waffenset-Editor (mit Kisten-Waffen)
+ Singleplayer-Spiel-Dialog erweitern (Optionen, mehr Team-Einstellungen, Templates laden/speichern)
[+ Netzwerk-Server-erstell GUI (ähnlich Singleplayer, evtl. verbinden mit s.o.)]
[+ Optionsmenü (Sprache, Video, Sound etc.)]
+ Locale-Tool ("missing id" finden, Locales vergleichen, aktuelle Locale neu laden)
+ im-spiel-dialog, der folgende aktionen anbietet: pause, spiel verlassen, speichern, demo aufnahmen, key bindings verändern, obiges optionsmenü


== Spiellogik/Gameengine ==
- physik: der wurm-blickwinkel ist etwas zu persistent; fliegt ein wurm nach links
  schaut er nach dem aufstehen trotzdem wieder nach rechts
- timing des lebenspunktcountdowns und der teamanzeige abstimmen:
    - temporäres "einfrieren" des spiels durch spielmodus, wenn etwas "passiert" ist (timer wird gestoppt, derzeitiger spieler muss warten bis der spielmodus die kontrolle wieder freigibt)
    - countdown der lebenspunkte
    - sich sprengende würmer
    - animation der teamanzeige
    - nachricht, die den tod/die feigheit eines wurmers mitteilt
* physik: box stacking
  (zusätzliche ideen: bewegende platformen, jump pads, wurmlöcher)
- physik: keine Kollision wenn ein Objekt innerhalb eines existierenden beweglichen erzeugt wird
  (so macht es wohl WWP; würde ein paar Probleme beim Projektil-Spawn lösen)
  nur wie genau? Probleme mit dicht beinander stehenden Objekten sollten vermieden werden
  ^ "richtige" Physikengines speichern Kontakte bzw. Paare überlappender Objekte permanent (über mehrere Iterationen), z.B. Chipmunk mit "Arbitern"... dann könnte man solche überlappende Paare, die durch Erzeugung eines Objektes entstanden sind, speziell Markieren und keine Reaktionskontakte erzeugen... wird die Überlappung aufgehoben, verschwindet auch die Markierung, und alles funktioniert normal wenn die Objekte wieder kollidieren
[- statt aktive Teams aktive TeamMembers]
+ Spiel-Statistiken, insb. Team- und Wurm-bezogene
    ^ die gibt es doch schon; müssen nur angezeigt werden
+ Mehr Powerup-Kisten (Niedrige Schwerkraft etc.)
+ Vergiftete Würmer (nach Sudden death oder Stinktiertreffer)
*** KI

== Spiel-Anzeige (Grafiken, Präsentation) ==
+ Partikel-Effekt für Explosionen, Wurm-nimmt-Schaden, kleine Explosionen (z.B. Minigun-Einschläge)
+ Partikel, die auf Sprite-Ereignisse reagieren (Kollision, Rutschen, Kontakt mit Wasser etc.)
- mehrere partikel-emitter an verschiedenen stellen erlauben (am besten in Sequence einbauen), statt ein emitter, der in der mitte des objekts emitiert
+ Partikel-Modifikations-Effekte (Explosion, Schwarzes Loch) in Spiel-Engine integrieren
+ Mehr "stub" gpl daten (Fragezeichen ersetzen, z.B. Dummy-Projektile die von der Engine gedreht werden)
*** gpl daten (vollständig)
[+ Kamera:
    - grundzustand: den aktiven, kontrollierten wurm fokusieren (kermacode durchsucht team-liste)
    - kameracode setzt einen callback, der jedesmal aufgerufen wird, wenn ein neues sprite erzeugt wird (man kann herausfinden, welches team das sprite "abgeschossen" hat)
    - neue waffen-sprites vom kontrollierten wurm werden sofort fokusiert
      wenn das sprite stirbt, wird der fokus nach kurzer zeit wieder auf einen wurm gesetzt
    - bewegt der user die kamera weg, wird der fokus auf waffen-sprites dauerhaft aufgehoben?
    - sonderbehandlung kisten: fokus beim erscheinen immer sofort setzen
      sobald kiste steht, fokus sofort wieder auf das vorherige objekt zurück
    ...]

== Waffen ==
+ Tierwaffen (Maulwurf, Maulwurfsangriff, Stinktier mit vergifteten Würmern)
+ Lokale-Suche-Waffen (Taube, Zauberkugel)
+ Bungee
+ Nahkampfwaffen (Firepunch, Kamikaze, Kamikaze-Bomber)

- Napalm verbessern (Ruckeln verhindern, Würmer mehr wegstoßen, vll. etwas "klebriger" machen)
- Molotov-Cocktail brennt über mehrere Züge

! Steuerung entrümpeln, unabhängig von Würmern machen (worm.d)
    - statt versuchen, wcontrol.d von worm.d unabhängig zu machen, lieber den rest des spiels von wcontrol.d unabhängig machen
    - alles im spiel sollte abstrakte tastenkombinationen registrieren können ("abstrakt" weil sie user-konfigurierbar sein sollen und über netzwerk funktionieren müssen)
    - manche davon sind nur zeitweise aktiv (nämlich würmer)
    - der rest (input.d, wcontrol.d, worm.d) kann das einfach benutzen und muss nicht weiter enthackt werden (oh alptraum)
    - dann braucht man noch eine kleine schnittstelle zwischen wcontrol.d und control.d und manchen waffen (beamen, bohrer...)


== level generator ==
! generator.d: möglicherweise level einfach als lua generator skript speichern?
+ beliebige game objekte in vorgenerierten leveln (ähnlich minen, aber vom leveldesigner platziert, beispiel: feste levelränder als objekte)
- Objekt-/Brückenplatzierung überarbeiten (Decke, Wand links/rechts etc.)
- Objekte und Brücken sind jede Runde anders platziert


== Netzwerk ==
[- Teams: Waffenset-Zuordnung, Lebenspunkte vom Server behandeln bzw. überprüfen,
         nicht allein den Client entscheiden lassen (Fairness)]
+ Server im Verbindungs-Dialog pingen bzw. mehr Informationen anzeigen
- Replays überprüfen/abstellen
- Fix für spielbeeinflussende Befehle (z.B. slowdown), die mom. keine Timestamps haben
+ Ready-Check zum Spielstart
*** Interpolation/Dead reckoning/Lag compensation/sowas in die Richtung, muhahar (siehe Deadlock/Boxen)
    http://bitbucket.org/h3r3tic/boxen/src/tip/src/xf/
*** determinismus garantieren (benutzung der FPU ist ein problem, da nicht alle plattformen die gleiche präzission für floating point haben), z.b. fixed point zahlen benutzen, oder regelmäßig zustand der clienten wieder synchronisieren
$ einfache erkennung von clients mit abweichender simulation (periodisch einen einfachen engine-hash berechnen und an den server schicken)
* Client-Netzwerkcode in Thread verlagern (Performance/genaue Ping-Werte)
+ folgende nutzlosen features sollten in der lobby-gui integriert sein:
    - möglichkeit den server öffentlich/privat zu machen (wird den server auch veranlassen, das announcen einzuschalten/einzustellen), ein passwort zu setzen, usw.
    - server name ändern (niemand wird die server.conf dafür editieren...)
    - nicknamen ändern?
    - hosts kicken/bannen oder privilegien geben
  vllt. damit warten, bis das GUI-chaos beseitigt ist

== nicht wirklich wichtig ==
- locales: übersetzungen vergleichen (z.b. de mit en -> fehlende einträge finden)
- task spezifische commandos/hotkeys (ähnlich wie in loadsafe.d)
   (und den gräuslichen hack in commandline.d entfernen)
- funktionalität von sky.d durch particles.d ersetzen
- GameConfig code säubern (absurde ansammlung von ConfigNodes)
- userverzeichnis im VFS unter /user statt / mounten => shadowing von beliebigen dateien im datenverzeichnis verhindern (obwohl das mal als feature gedacht war)
+ datenverzeichnis per kommandozeile setzbar machen
+ framework: resourcen sollten nach einer weile freigegeben werden; z.b. wenn eine OpenGL textur eine weile nicht benutzt wurde, diese einfach deallokieren
+ irgendetwas "einfacheres" zum definieren von waffen, spiellogik, etc., das auf dem Lua-zeugs aufbaut
- weniger Team IDs (name, id, netId, uniqueId)
* controller clusterfuck:
    - spiel sollte ohne controller (teams) startbar sein?
    - spieler sollten nicht zwingend WormSprite benutzen müssen
- könnte helfen für game engine-zeug http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/
  Game Programming Gems 6, Kapitel 4.6

== Wechsel der Programmiersprache ==

Das Projekt in eine andere Programmiersprache zu konvertieren wäre eine undankbare, langwierige Arbeit, und danach hätte man wahrscheinlich nur ein paar Features verloren und Bugs gewonnen. Trotzdem könnte es sein, dass einem D irgendwann so sehr auf die Nerven geht, um es zu riskieren.

Gute Kandidaten:
- C++: weite Verbreitung, hässliche Sprache, lange Compilezeiten
    => mag ich (faulty) nicht so
- C/C++ (C++ kompatibles C): noch weitere Verbeitung als C++, ziemlich umständlich manchmal (kein Operator-Overloading für Vektoren...), möglicherweise viel bessere Compilezeiten (besonders mit sowas wie TCC), teilweise Mischung mit C++ möglich
    => würde ich (faulty) vorziehen
- C#: ...
    => Mono (für Linux-Support) ist eher müllig, meh
- irgendwelche existierenden geskripteten 2D-Engines benutzen oder benutzen+erweitern
    => bloß was? LÖVE? PyGame? (halt, Python ist verboten langsam...)

Schlechte Kandidaten:
- D2: ist wie D1, mit ein paar zusätzlichen "Features" (wie das unsägliche const/immutable), ohne Tango, ein Phobos das um Tonnen von Bloat erweitert wurde (siehe z.B. http://d.puremagic.com/issues/show_bug.cgi?id=2254#c12), und kein gdc/ldc
    => nicht wirklich, haufen Arbeit und die gleichen Probleme (oder noch mehr)
- Scala: wäre interessant, aber ist (noch) beschränkt auf die Java-VM, und der Compiler ist langsam und buggy
- Java: igitt
- Go: ist höchst experimentiell, schlechter Windows-Support, schlechte GC die erzwungen wird, ...
- ActionScript+Flash: igitt
