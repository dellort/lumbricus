! PITA (hacks entfernen/neuschreiben, kompliziert, wenig gewinn),
- Fix/Change,
+ kleines Feature,
* großes, langfristiges Feature,
*** völlig unmöglich,
[] wurde versucht, aber nur kompromiss wurde implementiert oder es hat nicht geklappt

== RFCs (d.h. blablabla) ==
- kann sdl_sound nicht verwenden, weil sdl_sound anscheinend die länge der musik nicht
  zurückgibt => problem für "streaming" (nicht alles beim laden dekodiert)
  abhilfe:
  - musik (einige anwendung von "streaming") liefert ungültige länge zurück
  - die musik wird beim laden stückweise dekodiert, und die samples dabei
    weggeworfen => länge kann schnell (?) ausgerechnet werden
  + wozu brauchen wir die Musik-Länge überhaupt? Musik läuft nur im Hintergrund, bis man
    am Ende ankommt. Seeken könnte aber ein Problem werden
  + wir könnten auch einfach ffmpeg/libav* verwenden, der Code ist fertig und es gibt die
    Länge korrekt zurück. oder gibts noch mehr Hindernisse als die 9+ MB shared libraries?
- offensichtlich sollten alle sprites (nicht nur waffen) "events" haben, und die
  event-handler sollten in der .conf-datei deklariert werden
  1. gleich minid verwenden, und das alte action-zeug zur kompatibilität unverändert lassen?
  2. können ActionSprites und ProjectileSprite abgeschafft werden?
     (bis auf die tatsache, dass sie aufgrund der kompatibilität vorerst nicht entfernt werden,
      aber der rest des programmes wird sie nicht mehr verwenden)
  + ActionSprite existiert nur, um den Event-Code aus GObjectSprite rauszuhalten. Es spricht 
    nichts dagegen, dass alle Sprites ActionSprites sind, die Trennung würde ich aber gerne
    beibehalten. 
    ProjectileSprite war mir aber schon immer ein Dorn im Auge, nur weg damit
  + imo sollten "Events" von der Implementierung der Aktionen unabhängiger sein, die "Reaktion" 
    auf ein Event könnte dann als Action oder in Minid implementiert sein
  + schön wäre auch eine Verallgemeinerung der Events, so dass nicht nur Actions/Skripte, sondern
    auch Partikel und/oder Sounds erzeugt werden können, und das selbe System auch für 
    "GameEngine-Events" verwendet wird (z.B. ein Soundeffekt bei Spielstart, oder beim Sieg)
- das graphik-zeug aus gamepublic.d entfernen, und stattdessen direkt in die game engine
  verschieben?
  - würde codebloat entfernen und wäre ein bisschen schneller
  - integration von neuen graphik-effekten ist kein PITA mehr
  um das zu erreichen würde man:
  - Scene serialisierbar machen
  - GameEngine hätte eine eigene Scene
  - SceneZMix würde verwendet werden, um graphiken aus der client-engine und der server-engine
    zusammenzuführen (unter berücksichtigung der z-order)
  + Mir gefällt es nicht, so viel undeterministischen Code in GameEngine zu werfen, das erhöht
    die Gefahr von Determinismus-Fehlern. Ich hätte dich schon für den Explosions-Partikel-Code
    in GameEngine am liebsten geschlagen
  + Die Trennung von Engine und Darstellung fand ich immer ganz gut und übersichtlich. Die ganzen
    Interfaces sind allerdings irgendwie überflüssig. V.a. die Trennung Team/ServerTeam etc. nervt
  + Andererseits ist es schon lästig, Position/Geschwindigkeit etc. immer an die Szene weiterleiten
    zu müssen. Gerade mit Interpolation gehts aber wohl nicht anders, weil die Grafik/SceneObjects
    dann mit einer anderen Framerate als die Engine laufen
  zusätzlich würde ich triviale interpolation einbauen, die die bewegungen entweder
  a) zwischen zwei server frames interpoliert, oder
  b) nach dem letzten frame extrapoliert
  der zustand dazu könnte direkt in der server engine gespeichert werden (als transient)
  + Die Idee gefällt mir, dann könnte man gut die Engine-Framerate reduzieren. Solang der 
    Interpolationscode nicht zu langsam ist
  + a) würde ein Frame zusätzliches lokales Lag verursachen und braucht die vorige Position
    der Objekte; b) braucht keinen Zustand, dafür ist die Interpolation ungenau und verursacht 
    hässliche "Ruckel-Effekte" bei abrupten Flugbahnänderungen (d.h. wenns schiefgeht);
    -> Ich kann mich nicht entscheiden

== Sonstiges/Minor ==
! besser methode zum auslesen von confignodes (insbesondere mit fehlerbehandlung, so dass ungültige werte nicht still ignoriert werden, beliebige datentypen, user warnen über unbenutzte einträge; vielleicht einfach serialiaiserungscode wiederverwenden)
- configfile.d so ändern, dass datentypen schon in den nodes/in der syntax deklariert werden? libconfig verwenden?
+ editor/debug modus: spielzeit läuft nicht ab, untersuchung/platzierung von game objekten

== bekannte, lösbare Bugs ==
- wurm, der im napalm kocht, zeigt animation für unkontrollierten/schnellen fall an (sollte sein: rutsch animation)
- Superschaf fliegt auch 15sec weiter, wenn der Wurm nicht mehr dran ist
- Schwarzes Loch kann ertrinkende Würmer aus dem Wasser saugen; Ideen:
  Würmern erlauben, das Wasser wieder zu verlassen (und Zustand korrigieren)
- Bohrer/Lötlampe stoßen Würmer nicht weg
- Kisten erscheinen manchmal in der Landschaft oder an komischen Stellen
- sound in ordnung bringen, idiotische Sample/Music trennung aufheben, SDL_sound ausprobieren, sound effekte ins spiel integrieren
- runde kurz pausieren, um tote würmer sich sprengen zu lassen
  und kontrolle nehmen, wenn wurm gewonnen hat

== bekannte, unlösbare Bugs ==
- physik mehr wie wwp (z.b. wenn ein wurm nach unten fällt, bleibt er in wwp im boden stecken, zieht sich raus, und bleibt sitzen, während er in lumbricus wie ein gummiball abprallt)
- MiniD integrieren
- gui muss beim laden von savegames wiederhergestellt werden (spiele-einstellungsdialog)
- Projektil fliegt durch wenige Pixel dicke Landschaft, wenn der Wurm beim Feuern direkt davorsteht
! napalm ist sehr langsam, minenagriff nicht => ?


== GUI (allgemeine Features) ==
+ richtige GUI listen
+ key bindings editor
+ flash-artiges System für GUI-Animationen (widget einem pfad folgen lassen)
! styles system neuschreiben, fonts einschliessen, :blink state
*** GUI enthässlichen

== GUI spielspezifisch (Dialoge) ==
* Netzwerk-GUI (Spielerliste, Scores, Chat, Ping/Lag/Warte-auf-Server)
+ Waffenset-Editor (mit Kisten-Waffen)
+ Singleplayer-Spiel-Dialog erweitern (Optionen, mehr Team-Einstellungen, Templates laden/speichern)
[+ Netzwerk-Server-erstell GUI (ähnlich Singleplayer, evtl. verbinden mit s.o.)]
+ Optionsmenü (Sprache, Video, Sound etc.)
+ Locale-Tool ("missing id" finden, Locales vergleichen, aktuelle Locale neu laden)
+ Waffenfenster wegmachen wenns nicht gebraucht wird (insb. in Höhlenlevels lästig)
  wie denn?


== Spiellogik/Gameengine ==
* physik: box stacking
  (zusätzliche ideen: bewegende platformen, jump pads, wurmlöcher)
[- kein Force objekt für explosionen erzeugen]
- statt aktive Teams aktive TeamMembers
[- 1-frame bug bei würmern]
+ Spiel-Statistiken, insb. Team- und Wurm-bezogene
+ Mehr Powerup-Kisten (Niedrige Schwerkraft etc.), evtl. etwas "enthacken" (siehe z.B. controller.d, 1619)
*** KI
*** Scripting

== Spiel-Anzeige (Grafiken, Präsentation) ==
+ Partikel-Effekt für Explosionen, Wurm-nimmt-Schaden, kleine Explosionen (z.B. Minigun-Einschläge)
+ Partikel, die auf Sprite-Ereignisse reagieren (Kollision, Rutschen, Kontakt mit Wasser etc.)
- mehrere partikel-emitter an verschiedenen stellen erlauben (am besten in Sequence einbauen), statt ein emitter, der in der mitte des objekts emitiert
+ Partikel-Modifikations-Effekte (Explosion, Schwarzes Loch) in Spiel-Engine integrieren
+ Feuer-, Nachlade-, Wegsteckanimationen (kann evtl. in worm.d gehackt werden, statt sequence)
* sounds
* "stub" gpl daten (strichmännchen)
*** gpl daten (vollständig)
*** Sequence neuschreiben


== Waffen ==
+ Superwaffen (Teppichangriff, MB-Bombe etc.)
+ Lokale-Suche-Waffen (Taube, Zauberkugel)
+ Fallschirm, Bungee
+ Einfrieren

- Napalm verbessern (Ruckeln verhindern, Würmer mehr wegstoßen, vll. etwas "klebriger" machen)
- Molotov-Cocktail brennt über mehrere Züge
+ Luftangriff-Steuerung (Mauszeiger, links/rechts)
+ Waffen-Cooldown (z.B. für Napalmangriff; Wartezeit von x Sek. bis zum nächsten Schuss, Waffe bleibt aber ausgewählt)
+ Anzahl Projektile über Tasten 1-5 einstellen (Rindviecher)

! Steuerung entrümpeln, unabhängig von Würmern machen (worm.d)


== level generator ==
! generator.d: reduziere komplexität indem "generierte" level nur noch als lexel-array gespeichert werden (statt als gefüllte polygone); verschiebe das laden/speichern von savegames(bzw. netzwerk level) nach level.d; mache strukturen in level.d vllt. serialisierbar (statt manueller lade/speicher code); in generator.d würde nur noch code zum rendern bleiben + müllcode zum laden und speichern von templates (lol leveledit.d); vllt. savegames/netzwerklevels immer als komplette bitmap speichern?; danach kann glevel.d das zeug aus level.d direkt verwenden und ist weniger hackig
- hashcheck für savegames und insbesondere netzwerklevels
+ beliebige game objekte in vorgenerierten leveln (ähnlich minen, aber vom leveldesigner platziert, beispiel: feste levelränder als objekte)
- Objekt-/Brückenplatzierung überarbeiten (Decke, Wand links/rechts etc.)
- Objekte und Brücken sind jede Runde anders platziert


== Netzwerk ==
[- Teams: Waffenset-Zuordnung, Lebenspunkte vom Server behandeln bzw. überprüfen,
         nicht allein den Client entscheiden lassen (Fairness)]
+ Server im Verbindungs-Dialog pingen bzw. mehr Informationen anzeigen
- Replays überprüfen/abstellen
+ Savegames
- Fix für spielbeeinflussende Befehle (z.B. slowdown), die mom. keine Timestamps haben
+ Ready-Check zum Spielstart
*** Interpolation/Dead reckoning/Lag compensation/sowas in die Richtung, muhahar (siehe Deadlock)
*** determinismus garantieren (benutzung der FPU ist ein problem, da nicht alle plattformen die gleiche präzission für floating point haben), z.b. fixed point zahlen benutzen, oder regelmäßig zustand der clienten wieder synchronisieren
- einfache erkennung von clients mit abweichender simulation (periodisch einen einfachen engine-hash berechnen und an den server schicken)
* Client-Netzwerkcode in Thread verlagern (Performance/genaue Ping-Werte)

== nicht wirklich wichtig ==
[- userdaten (mergen von konfigfiles)]
- locales: übersetzungen vergleichen (z.b. de mit en -> fehlende einträge finden)
- task spezifische commandos/hotkeys (ähnlich wie in loadsafe.d)
   (und den gräuslichen hack in commandline.d entfernen)
- funktionalität von sky.d durch particles.d ersetzen
- GameConfig code säubern (absurde ansammlung von ConfigNodes)
