module game.levelgen.renderer;

//This module only renders auto-generated levels.
//It smoothes and draws the polygons generated by genrandom.d and also
//texturizes them.
//Also handles collision and in-game modification of the landscape.

import game.levelgen.landscape;
import framework.drawing;
import framework.surface;
import framework.main; //just for preloading images
import utils.vector2;
import utils.time;
import utils.list2;
import utils.log;
import utils.misc;
import utils.array : BigArray, arrayMap;
import drawing = utils.drawing;
import utils.gzip; //for MD5 digest

//don't know where to put this, moved it out of blastHole() because this thing
//affects the bitmap modification bounding box
enum int cBlastBorder = 4;

//can be set to a high value to disable tiling
enum int cTileSize = 256;

class LandscapeBitmap {
    private {
        Vector2i mSize;
        bool mDataOnly;
        //indexed mLevelData[y*mSize.x + x]
        //warning: points to C allocated data (via mLDStorage)
        Lexel[] mLevelData;
        //this keeps the reference to BigArray, so that mLevelData won'r be
        //  free'd (prevent BigArray's finalizer from being run)
        BigArray!(Lexel) mLDStorage;
        static LogStruct!("levelrenderer") mLog;

        static assert(Lexel.sizeof == 1);

        //blastHole: Distance from explosion outer circle to inner (free) circle
        enum int cBlastCenterDist = 25;

        int[][] mCircles; //getCircle()

        //indexed mTiles[ty*mTilesX + tx]
        //the tiles are sorted by position
        //all tiles have the same size, except possibly the bottom/right tiles
        Tile[] mTiles;
        //number of tiles
        int mTilesX, mTilesY;

        //temporary and for debugging
        PixelAccess mAccess;

        //downscaled image of the level for previewing, with solid colors
        //this is updated with mLevelData and the level image tiles
        //is null as long as previewing wasn't enabled with previewInit()
        Surface mPreviewImage;
        Vector2f mPreviewScale;
        int[] mPreviewScaleX;
        //user defined color mapping
        Color.RGBA32[Lexel.Max+1] mPreviewColors;
    }

    private struct Tile {
        Vector2i pos, size; //absolute pixel position and surface.size
        int tx, ty;         //tile position
        Surface surface;

        //temporary during accessing pixels
        //PixelAccess takes care of this
        Color.RGBA32* _pixels;
        size_t _pitch;
    }

    private struct TexData {
        //also not good and nice
        size_t pitch;
        uint w, h;
        Color.RGBA32* data;
        Vector2i offs;

        private Surface mSurface;
        private Color.RGBA32 mPixel;

        void set(Surface s, Color fallback = Color(0,0,0,0)) {
            mSurface = s;
            if (s) {
                w = s.size.x;
                h = s.size.y;
                lock();
            } else {
                //simulate an image consisting of a single transparent pixel
                mPixel = fallback.toRGBA32();
                data = &mPixel;
                w = h = 1;
                pitch = 1;
            }
        }

        void lock() {
            if (mSurface)
                mSurface.lockPixelsRGBA32(data, pitch);
        }

        void release() {
            if (mSurface)
                mSurface.unlockPixels(Rect2i.init);
        }
    }

    //helper class for PixelAccess
    //the idea is that opApply style iterating is much slower than using a
    //  struct, and also allows inlining better
    //you are allowed to iterate through a tile part of the scanline manually
    //  for more speed; you can increment x and px until you reach x2 or
    //  tile_end, and in case of px==tile_end, call next_tile()
    private struct ScanlineIter {
        //consider all elements read-only for the user
        //except if iterating manually (x and px can be incremented)

        //absolute x coordinate
        int x;
        //points into current pixel into current tile
        Color.RGBA32* px;
        //points after last pixel (px >= tile_end means iteration done)
        Color.RGBA32* tile_end;
        //absolute x coordinate where iteration should be finished
        //(iterate as long as x<x2)
        int x2;

        int y;

        Tile* current_tile;
        LandscapeBitmap owner;

        //go to next pixel
        //px will be invalid if x >= x2 (after the call)
        void next_x() {
            x++;
            px++;
            if (px >= tile_end && x < x2) {
                next_tile();
            }
        }

        //go to next tile
        void next_tile() {
            assert(!!owner.mAccess);
            assert(current_tile.tx + 1 < owner.mTilesX, "no more tiles");
            //for now, assume x starts at 0 in the tile - could be relaxed
            assert(px is tile_end);
            //this is just current_tile++;
            Tile* ntile = &owner.mTiles[current_tile.ty*owner.mTilesX +
                current_tile.tx + 1];
            current_tile = ntile;
            //same assumption about x starting at 0
            assert(x == current_tile.pos.x);
            owner.mAccess.lock_tile(current_tile);
            px = current_tile._pixels
                + (y - current_tile.pos.y) * current_tile._pitch;
            assert(current_tile.size.x <= current_tile._pitch);
            tile_end = px + current_tile.size.x;
        }
    }

    //this class takes care about locking and unlocking Surfaces from multiple
    //  tiles, and simplifies pixel access to them
    private final scope class PixelAccess {
        int _tx1, _ty1, _tx2, _ty2;
        bool _was_released = false;
        this() {
            _tx1 = _ty1 = int.max;
            _tx2 = _ty2 = int.min;
            //multiple PixelAccesses at a time just won't work (Surface locking)
            assert(!mAccess);
            mAccess = this;
        }

        //start iterating at the given pixel
        //positions out of bounds are assert()ed
        ScanlineIter get_iter(int y, int x1, int x2) {
            ScanlineIter iter;
            iter.owner = this.outer;
            iter.x = x1;
            iter.x2 = x2;
            iter.y = y;
            //too many special cases for this below
            if (iter.x >= iter.x2)
                return iter;
            //beware of the off-by-one errors
            //y exclusive for now
            assert(y >= 0 && y < mSize.y && x1 >= 0 && x1 < mSize.x
                && x2 >= 0 && x2 <= mSize.x && x1 < x2);
            int tx = x1 / cTileSize;
            int ty = y / cTileSize;
            Tile* t = &mTiles[ty*mTilesX + tx];
            iter.current_tile = t;
            lock_tile(t);
            iter.px = t._pixels + (y - t.pos.y) * t._pitch;
            iter.tile_end = iter.px + t.size.x;
            iter.px += iter.x - t.pos.x;
            return iter;
        }

        //makes sure Tile._pixels and Tile._pitch are filled
        //the Surface will be unlocked again on done()
        void lock_tile(Tile* tile) {
            if (tile._pixels)
                return;
            _tx1 = min(_tx1, tile.tx);
            _ty1 = min(_ty1, tile.ty);
            _tx2 = max(_tx2, tile.tx);
            _ty2 = max(_ty2, tile.ty);
            tile.surface.lockPixelsRGBA32(tile._pixels, tile._pitch);
        }

        //read-only done()
        void done() {
            done(Rect2i.init, true);
        }
        //read-write done() (re-uploads all pixels in the rect)
        void done(Rect2i rc, bool read_only = false) {
            assert(!_was_released);
            _was_released = true;

            if (_tx1 > _tx2 || _ty1 > _ty2) {
                check_unreleased();
                return;
            }

            //change rect has size 0 => no pixels re-uploaded
            if (read_only)
                rc = Rect2i.init;

            for (int ty = _ty1; ty <= _ty2; ty++) {
                for (int tx = _tx1; tx <= _tx2; tx++) {
                    Tile* t = &mTiles[ty*mTilesX + tx];
                    if (t._pixels) {
                        t.surface.unlockPixels(rc - t.pos);
                        t._pixels = null;
                        t._pitch = 0;
                    }
                }
            }

            check_unreleased();
        }

        void check_unreleased() {
            /+
            debug {
                foreach (ref Tile t; mTiles) {
                    assert(!t._pixels);
                }
            }
            +/
        }

        ~this() {
            //Warning: this is called even when an failed assert (or any
            //  Exception) unwinds the stack; as a consequence, the following
            //  asserts may hide and throw away the original Exception
            //  cf. dmd bug 4223
            assert(_was_released, "done() not called");
            assert(mAccess is this);
            mAccess = null;
            check_unreleased();
        }
    }


    //create an empty Landscape of passed size
    //  dataOnly: false will also generate a textured Landscape bitmap,
    //            true only creates a Lexel[] (this.image will return null)
    //  data: set to use Lexel data, null to start empty
    //data is never copied; xxx change that and use BigArray for store, or so
    this(Vector2i a_size, bool dataOnly = false, Lexel[] data = null) {
        argcheck(a_size.x >= 0 && a_size.y >= 0);
        mSize = a_size;
        mLDStorage = new BigArray!(Lexel)(mSize.x * mSize.y);
        mLevelData = mLDStorage[];
        mDataOnly = true;
        if (data.length > 0) {
            argcheck(data.length == mSize.x*mSize.y);
            mLevelData[] = data;
        }

        if (!dataOnly)
            addImage();
    }

    //create from a bitmap; also used as common constructor
    //bmp = the landscape-bitmap, must not be null
    //import_bmp = create the metadata from the image's transparency information
    //      if false, initialize metadata with Lexel.init
    //memory managment: bmp is just copied
    this(Surface bmp, bool import_bmp = true) {
        this(bmp.size);

        //bmp -> level bitmap, but tiled
        foreach (ref Tile t; mTiles) {
            t.surface.copyFrom(bmp, Vector2i(0), t.pos, t.size);
        }

        //create mask

        if (!import_bmp)
            return;

        scope pixels = new PixelAccess();

        for (int y = 0; y < mSize.y; y++) {
            auto iter = pixels.get_iter(y, 0, mSize.x);
            Lexel* meta = &mLevelData[y*mSize.x];
            while (iter.x < iter.x2) {
                *meta = pixelIsTransparent(iter.px) ? Lexel.Null
                    : Lexel.SolidSoft;
                meta++;
                iter.next_x();
            }
        }

        pixels.done();
    }

    //just an empty ctor for copy()
    private this() {
    }

    //XXXTANGO was dispose
    void free() {
        //super.dispose();
        previewDestroy();
        foreach (ref t; mTiles) {
            t.surface.free();
        }
        delete mTiles;
        mLevelData = null;
        delete mLDStorage;
    }

    //if the level was created as "data only", add the image part
    //this means after this call the level is not data only anymore
    //after this, you may want to call texturizeData() to get something visible
    void addImage() {
        //mDataOnly must correspond with the image existing
        assert((mTiles.length == 0) == mDataOnly);

        if (!mDataOnly)
            return;

        mTilesX = (mSize.x + cTileSize - 1) / cTileSize;
        mTilesY = (mSize.y + cTileSize - 1) / cTileSize;
        mTiles.length = mTilesX * mTilesY;
        for (int ty = 0; ty < mTilesY; ty++) {
            for (int tx = 0; tx < mTilesX; tx++) {
                Tile* t = &mTiles[ty*mTilesX+tx];
                t.tx = tx;
                t.ty = ty;
                t.pos = Vector2i(tx, ty) * cTileSize;
                t.size = Vector2i(cTileSize).min(mSize - t.pos);
                t.surface = new Surface(t.size);
                t.surface.enableCaching = false;
                t.surface.fill(Rect2i(mSize), Color.Transparent);
            }
        }

        mDataOnly = false;
    }

    //return if the level has an image, i.e. is not "data only"
    bool hasImage() {
        return !mDataOnly;
    }

    //return a full, untiled surface for the level bitmap
    Surface createImage() {
        argcheck(!mDataOnly, "Not for data-only renderer");
        //xxx transparency mode?
        Surface s = new Surface(mSize);
        foreach (ref t; mTiles) {
            s.copyFrom(t.surface, t.pos, Vector2i(0), t.size);
        }
        return s;
    }

    LandscapeBitmap copy(bool dataOnly = false) {
        auto ret = new LandscapeBitmap();
        ret.mSize = mSize;
        ret.mLDStorage = mLDStorage.copy();
        ret.mLevelData = ret.mLDStorage[];
        if (dataOnly) {
            ret.mDataOnly = true;
        } else {
            ret.mDataOnly = mDataOnly;
            ret.mTilesX = mTilesX;
            ret.mTilesY = mTilesY;
            ret.mTiles = mTiles.dup;
            foreach (ref Tile t; ret.mTiles) {
                t.surface = t.surface.clone;
                t.surface.enableCaching = false;
            }
        }
        //don't copy preview stuff
        return ret;
    }

    public Vector2i size() {
        return mSize;
    }

    //return a copy of the lexel array
    //you can/should free the result with delete when you're done
    Lexel[] copyLexels() {
        return mLevelData.dup; //will allocate normal D memory
    }

    //get a reference to the lexel array
    //this is slightly dangerous, because the array is allocated in C memory
    //as long as you have a reference to this LandscapeBitmap and don't call
    //  LandscapeBitmap.free(), you'll be fine
    Lexel[] peekLexels() {
        return mLevelData;
    }

    void draw(Canvas c, Vector2i pos) {
        foreach (ref Tile t; mTiles) {
            c.draw(t.surface, pos + t.pos);
        }
    }

    //before calling draw() the first time (completely optional)
    void prepareForRendering() {
        foreach (ref Tile t; mTiles) {
            gFramework.preloadResource(t.surface);
        }
    }

    //create a preview image
    //it can be queried with .previewImage(), which is kept up-to-date
    void previewInit(Vector2i s, Color[Lexel] lexel2color) {
        argcheck(!mPreviewImage, "preview image already exists");
        argcheck(s.x <= mSize.x && s.y <= mSize.y, "Can only scale down");
        argcheck(s.x >= 0 && s.y >= 0);

        //scale down from full size to image size
        mPreviewScale = Vector2f((cast(float)s.x)/mSize.x,
            (cast(float)s.y)/mSize.y);
        assert(mPreviewScale.x >= 0 && mPreviewScale.y >= 0);
        //precalc scaled x values (speed ~*2)
        mPreviewScaleX = new int[s.x];
        for (int x = 0; x < s.x; x++) {
            mPreviewScaleX[x] = min(cast(int)(x/mPreviewScale.x), mSize.x);
        }

        //xxx init with default values, if not in lexel2color?
        foreach (Lexel l, Color c; lexel2color) {
            if (l >= mPreviewColors.length)
                continue;
            mPreviewColors[l] = c.toRGBA32();
        }

        mPreviewImage = new Surface(s);

        previewUpdate(Rect2i(mSize));
    }

    //release the preview image, so subsequent drawing commands won't slow
    //  down everything due to preview image updating
    void previewDestroy() {
        if (!mPreviewImage)
            return;
        mPreviewImage.free();
        mPreviewImage = null;
    }

    //destroy previewing from level and return the preview surface
    //ownership of the preview surface is transferred to caller
    Surface previewSteal() {
        auto res = mPreviewImage;
        mPreviewImage = null;
        return res;
    }

    //return preview image; ownership still belongs to LandscapeBitmap;
    //  especially it will be updated as draw methods are executed on the
    //  landscape, and it will be free'd by previewDestroy()
    //this can be null; call previewInit() to create it
    Surface previewImage() {
        return mPreviewImage;
    }

    //convenience method to quickly take a preview without permanent effects
    Surface renderPreview(Vector2i s, Color[Lexel] lexel2color) {
        //xxx: it really shouldn't have permanent effects, but this
        //  implementation messes up hard if there's already a preview set - it
        //  really should do it somehow independently (meh, too lazy to move the
        //  code around right now)
        previewInit(s, lexel2color);
        return previewSteal();
    }

    //this should be called as mLevelData is updated
    //  exceptions: .fill(), constructors
    private void previewUpdate(Rect2i rc) {
        if (!mPreviewImage || rc.p2.x <= rc.p1.x || rc.p2.y <= rc.p1.y)
            return;

        rc.fitInsideB(Rect2i(mSize));

        //scale down
        Rect2i s_rc = void;
        s_rc.p1 = toVector2i(toVector2f(rc.p1) ^ mPreviewScale);
        s_rc.p2 = toVector2i(toVector2f(rc.p2) ^ mPreviewScale);
        s_rc.fitInsideB(mPreviewImage.rect());

        Color.RGBA32* data;
        size_t pitch;
        mPreviewImage.lockPixelsRGBA32(data, pitch);

        for (int y = s_rc.p1.y; y < s_rc.p2.y; y++) {
            int py = cast(int)(y/mPreviewScale.y); //unscaled y
            assert(py >= 0 && py < mSize.y);
            Lexel* inPtr = &mLevelData[py*mSize.x];
            Color.RGBA32* outPtr = data + y*pitch + s_rc.p1.x;
            for (int x = s_rc.p1.x; x < s_rc.p2.x; x++) {
                /+
                //this is the most stupid scaling algorithm:
                //if a pixel is set anywhere in the source area, the dest
                //pixel is set, using the highest lexel found
                outPtr = outPtrL+*(pxt.ptr+x);
                *outPtr = max(*outPtr, *inPtr);
                inPtr++;
                +/
                //minimal scaling effort for speed
                //though the idea above really made it look somewhat better
                //microoptimization, out-of-bounds lexels (microbloat?)
                //-- *outPtr = mPreviewColors[inPtr[mPreviewScaleX[x]]];
                ubyte p = *(inPtr + *(mPreviewScaleX.ptr + x));
                *outPtr = *(mPreviewColors.ptr + min(p, mPreviewColors.length));
                outPtr++;
            }
        }

        mPreviewImage.unlockPixels(s_rc);
    }


    //for rasterize()
    struct RasterCtx {
        Vector2i texoffs; //can be set by user for surface displacement
        void delegate(int x1, int x2, int y) scanline;
    }

    //this function will setup a RasterCtx and then call dg() with it
    //you can call RasterCtx.scanline() to rasterize a span
    //dorasterize() will use l/s for rendering it, and will clip, draw,
    //  automatically update the dirty rect, and so on
    //s can be null (intended for data-only renderers)
    void rasterize(Surface s, Lexel l, scope void delegate(ref RasterCtx) dg) {
        Rect2i drc = Rect2i.Abnormal();

        scope pixels = new PixelAccess();

        TexData tex;
        tex.set(s);

        RasterCtx ctx;

        void scanline(int x1, int x2, int y) {
            //xxx confusion about x2 being inclusive or exclusive
            //for now, it's exclusive

            //clipping
            if (y < 0 || y >= mSize.y) return;
            if (x1 < 0) x1 = 0;
            if (x2 > mSize.x) x2 = mSize.x;
            if (x2 < x1) return;
            //dirty rect
            if (x1 < drc.p1.x) drc.p1.x = x1;
            if (x2 > drc.p2.x) drc.p2.x = x2;
            if (y < drc.p1.y) drc.p1.y = y;
            if (y+1 > drc.p2.y) drc.p2.y = y+1;
            //actually draw
            int ly = y*mSize.x;
            mLevelData[ly+x1 .. ly+x2] = l;
            if (!mDataOnly) {
                uint ty = (y + ctx.texoffs.y) % tex.h;
                uint x_offs = ctx.texoffs.x;
                Color.RGBA32* texptr = tex.data + ty*tex.pitch;
                auto iter = pixels.get_iter(y, x1, x2);
                while (iter.x < iter.x2) {
                    auto texel = texptr + (iter.x + x_offs) % tex.w;
                    *iter.px = *texel;
                    iter.next_x();
                }
            }
        }

        ctx.scanline = &scanline;
        dg(ctx);

        tex.release();

        pixels.done(drc);

        previewUpdate(drc);
    }

    void drawRect(Surface s, Lexel l, Rect2i rc) {
        rasterize(s, l, (ref RasterCtx c) {
            for (int y = rc.p1.y; y < rc.p2.y; y++) {
                c.scanline(rc.p1.x, rc.p2.x, y);
            }
        });
    }

    void drawCircle(Surface s, Lexel l, Vector2i p, int r) {
        rasterize(s, l, (ref RasterCtx c) {
            drawing.circle(p.x, p.y, r, c.scanline);
        });
    }

    //originally implemented for debugging
    void drawLine(Surface s, Lexel l, Vector2i p1, Vector2i p2) {
        rasterize(s, l, (ref RasterCtx c) {
            drawing.line(p1, p2, (Vector2i p) {
                c.scanline(p.x, p.x + 1, p.y);
            });
        });
    }

    //draw a polygon; it's closed by the line points[$-1] - points[0]
    //"marker" is the value that should be written into the Level.mData array,
    //if a pixel is coverered by this polygon
    //subdiv: if subdivision should be done
    //"visible" is true if the polygon should appear in the image surface
    //nosubdiv: indices for points that start lines which shouldn't be
    //  "interpolated" (they won't be changed)
    //"texture" is used to fill the new polygon, if it is null, make all pixels
    //  covered by the polygon transparent
    //historical note: points was changed from Vector2f
    void addPolygon(Vector2i[] points, Vector2i texture_offset, Surface texture,
        Lexel marker, bool subdiv = false, uint[] nosubdiv = null)
    {
        addPolygonScaled(Vector2f(1.0), points, texture_offset, texture, marker,
            subdiv, nosubdiv);
    }

    //like addPolygon(), but each item of points is multiplied with scale
    //the texture pixels will have the same size as unscaled
    void addPolygonScaled(Vector2f scale, Vector2i[] points,
        Vector2i texture_offset, Surface texture, Lexel marker,
        bool subdiv = false, uint[] nosubdiv = null)
    {
        //meh
        auto pt = arrayMap(points, (Vector2i p) {
            return toVector2f(p).mulEntries(scale);
        });

        if (subdiv) {
            auto pt2 = drawing.cornercut(pt, nosubdiv);
            delete pt;
            pt = pt2;
        }

        rasterize(texture, marker, (ref RasterCtx ctx) {
            ctx.texoffs = texture_offset;
            drawing.rasterizePolygon(Rect2i(mSize), pt, ctx.scanline);
        });

        /+ forgotten debugging code
        auto s = new Surface(Vector2i(1));
        s.fill(s.rect, Color(1,0,0));
        for (size_t x = 0; x < pt.length + 1; x++) {
            Vector2f p1 = pt[x % $];
            Vector2f p2 = pt[(x+1) % $];
            drawLine(s, Lexel.SolidSoft, toVector2i(p1), toVector2i(p2));
            drawCircle(s, Lexel.SolidSoft, toVector2i(p1), 3);
        }
        +/

        delete pt;
    }

    //thick line with rounded caps
    //no idea what square is
    void drawSegment(Surface s, Lexel l, Vector2i p1, Vector2i p2, int radius,
        bool square = false)
    {
        rasterize(s, l, (ref RasterCtx ctx) {
            //just for convenience
            void drawRect(Vector2i p, int radius) {
                for (int y = p.y-radius; y < p.y+radius; y++) {
                    ctx.scanline(p.x-radius, p.x+radius-1, y);
                }
            }

            if (square)
                drawRect(p1, radius);
            else
                drawing.circle(p1.x, p1.y, radius, ctx.scanline);
            if (p1 == p2)
                return;
            if (square)
                drawRect(p2, radius);
            else
                drawing.circle(p2.x, p2.y, radius, ctx.scanline);
            Vector2f[4] poly;
            if (!square) {
                Vector2f line_o = toVector2f(p2-p1).orthogonal.normal;
                poly[0] = toVector2f(p1)-line_o*radius;
                poly[1] = toVector2f(p1)+line_o*radius;
                poly[2] = toVector2f(p2)+line_o*radius;
                poly[3] = toVector2f(p2)-line_o*radius;
            } else {
                int r = radius;
                if (p1.x > p2.x && p1.y > p2.y
                    || p1.x < p2.x && p1.y < p2.y)
                {
                    poly[0] = toVector2f(p1+Vector2i(r, -r));
                    poly[1] = toVector2f(p1+Vector2i(-r, r));
                    poly[2] = toVector2f(p2+Vector2i(-r, r));
                    poly[3] = toVector2f(p2+Vector2i(r, -r));
                } else {
                    poly[0] = toVector2f(p1+Vector2i(r, r));
                    poly[1] = toVector2f(p1+Vector2i(-r, -r));
                    poly[2] = toVector2f(p2+Vector2i(-r, -r));
                    poly[3] = toVector2f(p2+Vector2i(r, r));
                }
            }
            drawing.rasterizePolygon(Rect2i(size), poly, ctx.scanline);
        });
    }

    //fast clearing
    void fill(Color c, Lexel l) {
        mLevelData[] = l;
        foreach (ref t; mTiles) {
            t.surface.fill(t.surface.rect, c);
        }
        if (mPreviewImage) {
            mPreviewImage.fill(mPreviewImage.rect, c);
        }
    }

    //create a level image from the Lexel[] by applying textures
    //overwrites the existing image
    //arrays are indexed by Lexel
    void texturizeData(Surface[] textures, Vector2i[] texOffsets) {
        assert(mLevelData.length == mSize.x*mSize.y);

        //could create the image
        //right now, this function is only called with the image pre-created
        argcheck(!mDataOnly);

        //prepare textures (one for each marker)
        TexData[Lexel.Max+1] texData;
        for (int idx = 0; idx <= Lexel.Max; idx++) {
            Surface t;
            if (idx < textures.length)
                t = textures[idx];
            texData[idx].set(t);
            if (idx < texOffsets.length) {
                texData[idx].offs = texOffsets[idx];
            }
        }

        scope pixels = new PixelAccess();

        Color.RGBA32*[Lexel.Max+1] texptr;

        for (int y = 0; y < size.y; y++) {
            //for each texture, get pointer to current texture line
            for (int i = 0; i < texptr.length; i++) {
                int ty = (y + texData[i].offs.y) % texData[i].h;
                texptr[i] = texData[i].data + ty*texData[i].pitch;
            }
            //current line in data array
            Lexel* src = mLevelData.ptr + y*size.x;
            //destination pixel
            auto iter = pixels.get_iter(y, 0, size.x);
            while (iter.x < iter.x2) {
                Lexel l = *src;
                if (l >= texData.length)
                    l = Lexel.init;
                Color.RGBA32* texel = texptr[l]
                    + (iter.x + texData[l].offs.x) % texData[l].w;
                *iter.px = *texel;
                src++;
                iter.next_x();
            }
        }

        pixels.done(Rect2i(mSize));

        foreach (ref TexData t; texData) {
            t.release();
        }

        previewUpdate(Rect2i(mSize));
    }

    //it's a strange design decision to do it _that_ way. sorry for that.
    //draw a border in "a", using that texture, where "a" forms a border to "b"
    //draws top and bottom borders with different textures
    //  tex_up !is null:   draw bottom border with texture "tex_up"
    //  tex_down !is null: draw top border with texture "tex_down"
    void drawBorder(Lexel a, Lexel b, Surface tex_up, Surface tex_down) {
        argcheck(!mDataOnly, "No border drawing for data-only renderer");

        ubyte[] apline;
        scope pixels = new PixelAccess();

        //it always scans in the given direction; to draw both borders where "a"
        //is on top ob "b" and where "b" is on top of "a", you have to call this
        //twice (which isn't a problem, since you might want to use different
        //textures for this)
        //"up": false=scan up-to-down, true=scan down-to-up ("a" und "b" are
        // also checked in that order)
        //"texture" must not be null
        void drawBorderInt(Lexel a, Lexel b, bool up, Surface texture,
            ubyte[] tmpData)
        {
            int dir = up ? -1 : +1;

            size_t tex_pitch;
            Color.RGBA32* texptr;
            texture.lockPixelsRGBA32(texptr, tex_pitch);
            uint tex_w = texture.size.x;
            uint tex_h = texture.size.y;

            auto dsttransparent = Color.Transparent.toRGBA32();

            apline[] = 0; //initialize to 0
            int start = up ? mSize.y-1 : 0;
            for (int y = start; y >= 0 && y <= mSize.y-1; y += dir) {
                Lexel* meta_scanline = &mLevelData[y*mSize.x];
                ubyte* poldline = &tmpData[y*mSize.x];
                ubyte* ppline = &apline[0];
                auto iter = pixels.get_iter(y, 0, mSize.x);
                while (iter.x < iter.x2) {
                    //the data written into ppline is used by the next pass in
                    //the other direction
                    ubyte pline = *ppline;

                    if (*meta_scanline == a) {
                        if (pline == 0xFF)
                            pline = cast(ubyte)(tex_h+1);
                        if (pline > 0)
                            pline -= 1;
                    } else if (*meta_scanline == b) {
                        pline = 0xFF;
                    } else {
                        pline = 0;
                    }

                    *ppline = pline;

                    //set the pixel accordingly
                    //comparison with *oldpline ensures that up and down texture
                    //use the same part of the available space
                    if (pline > 0 && pline < 0xFF && pline > *poldline) {
                        Color.RGBA32* texel = texptr + iter.x % tex_w;
                        uint texy = (tex_h-pline)%tex_h;
                        texel = texel + texy*tex_pitch;
                        if (!pixelIsTransparent(texel))
                            *iter.px = *texel;
                        else {
                            //XXX assumption: parts of the texture that should
                            //render transparent only take half of the y space
                            if (texy < tex_h/2) {
                                //set current pixel transparent
                                *iter.px = dsttransparent;
                                *meta_scanline = Lexel.Null;
                            }
                        }
                    }

                    meta_scanline++;
                    ppline++;
                    poldline++;
                    iter.next_x();
                }
                //save current pline for next pass in other direction
                tmpData[y*mSize.x..(y+1)*mSize.x] = apline;
            }

            texture.unlockPixels(Rect2i.init);
        }

        //stores temporary data between up and down pass
        scope tmp_array = new BigArray!(ubyte)(mSize.x*mSize.y);
        ubyte[] tmp = tmp_array[];

        scope apline_array = new BigArray!(ubyte)(mSize.x);
        apline = apline_array[];

        if (tex_down)
            drawBorderInt(a, b, false, tex_down, tmp);
        if (tex_up)
            drawBorderInt(a, b, true, tex_up, tmp);

        pixels.done(Rect2i(mSize));
    }

    //render a circle on the surface
    // w, h: source bitmap width and height
    // meta_mask, meta_cmp: actually copy pixel if (meta & mask) == cmp
    // meta_domask: after checking and copying the pixel, mask meta with this
    //I put it all into this to avoid code duplication
    //called in-game!
    private int circle_masked(PixelAccess pixels, Vector2i pos, int radius,
        ref TexData tex,
        ubyte meta_mask, ubyte meta_cmp, ubyte meta_domask = 255)
    {
        assert(radius >= 0);
        auto st = pos;
        int[] circle = getCircle(radius);
        int count;

        for (int y = -radius; y <= radius; y++) {
            int ly = st.y + y;
            if (ly < 0 || ly >= mSize.y)
                continue;
            int xoffs = radius - circle[y+radius];
            int x1 = st.x - xoffs;
            int x2 = st.x + xoffs + 1;
            //clipping
            x1 = max(x1, 0);
            x1 = min(x1, mSize.x);
            x2 = max(x2, 0);
            x2 = min(x2, mSize.x);
            if (x1 >= x2)
                continue;
            Color.RGBA32* srcptr = tex.data+tex.pitch*(ly % tex.h);
            uint w = tex.w;
            Lexel* meta = mLevelData.ptr + mSize.x*ly + x1;
            auto iter = pixels.get_iter(ly, x1, x2);
            while (iter.x < iter.x2) {
                bool set = ((*meta & meta_mask) == meta_cmp);
                if (set) {
                    *iter.px = *(srcptr+(iter.x % w));
                    count++;
                }
                //yes, unconditionally
                *meta &= meta_domask;
                meta++;
                iter.next_x();
            }
        }
        return count;
    }

    //destroy a part of the landscape
    //called in-game!
    //  pos = center of the damage
    //  radius = radius of the circle around pos making up the now free area
    //  blast_border = added to radius for the area of the solid but modified
    //     area (on the border, the image is changed, but not the metadata) is
    //     pixels outside the circle (radius+blast_border) aren't touched)
    //  theme = bitmaps to use as background etc. (can be null)
    public int blastHole(Vector2i pos, int radius, int blast_border,
        LandscapeTheme theme = null)
    {
        argcheck(!mDataOnly, "Not for data-only renderer");
        enum ubyte cAllMeta = Lexel.SolidSoft | Lexel.SolidHard;

        assert(radius >= 0);
        assert(blast_border >= 0);

        //record if there were any changes to the image
        //if not, don't need to re-upload the texture to the OpenGL driver
        //xxx: probably doing a checkAt() here and exiting the function if there
        //  are no pixels (according to the collision result) would be better?
        int change = 0;

        uint col;
        int count;

        scope pixels = new PixelAccess();

        auto nradius = max(radius - cBlastCenterDist,0);

        //call circle_masked(), with either the Surface s or the Color c
        //if s !is null, only the surface is used, else use the color
        int doCircle(int radius, Surface s, Color c, ubyte meta_mask,
            ubyte meta_cmp, ubyte meta_domask = 255)
        {
            TexData tex;
            tex.set(s, c);
            int x_count = circle_masked(pixels, pos, radius, tex,
                meta_mask, meta_cmp, meta_domask);
            tex.release();
            change += x_count;
            return x_count;
        }

        //draw the background image into the area to be destroyed
        //actually, you can only see a ring of that background image; the center
        //of the destruction is free landscape (except for SolidHard pixels)
        //the center is cleared later to achieve this
        //in the same call, mask all pixels with SolidHard to remove any
        //SolidSoft pixels...
        count = doCircle(radius, theme ? theme.backImage : null,
            theme ? theme.backColor : Color.Transparent,
            cAllMeta, Lexel.SolidSoft, Lexel.SolidHard);

        int blast_radius = radius + blast_border;

        //draw that funny border; the border is still solid and also is drawn on
        //solid ground only (except for SolidHard pxiels: they stay unchanged)
        //because all SolidSoft pixels were cleared above, only the remaining
        //landscape around the destruction will be coloured with this border...
        if (theme) {
            doCircle(blast_radius, theme.borderImage, theme.borderColor,
                cAllMeta, Lexel.SolidSoft);
        }

        if (nradius > 0) {
            //clear the center of the destruction (to get rid of that background
            //texture)
            doCircle(nradius, null, Color.Transparent, cAllMeta, 0);
        }

        Rect2i bb;
        if (change) {
            bb.p1 = pos - Vector2i(blast_radius);
            bb.p2 = pos + Vector2i(blast_radius);
        }
        pixels.done(bb);

        previewUpdate(bb);

        return count;
    }

    //calculate normal at that position
    //this is (very?) expensive
    //maybe replace it by other methods as used by other worms clones
    // circle = if true check a circle, else a quad, with sides (radius*2+1)^2
    // dir = not-normalized diection which points to the outside of the level
    // count = number of colliding pixels
    // bits = lexel bits of all collided landscape pixels or'ed together
    public void checkAt(Vector2i pos, int radius, bool circle,
        out Vector2i out_dir, out int out_count, out uint out_bits)
    {
        argcheck(radius >= 0);
        //xxx: I "optimized" this, the old version is still in r451
        //     further "optimized" (== obfuscated for no gain) after r635
        //     made it completely incomprehensible after r940

        int[] acircle = circle ? getCircle(radius) : null;
        int count;
        uint bits;
        int d_x, d_y;

        //dir and count are initialized with 0

        int ly1 = max(pos.y - radius, 0);
        int ly2 = min(pos.y + radius + 1, mSize.y);
        for (int y = ly1; y < ly2; y++) {
            int xoffs = radius;
            if (circle) {
                xoffs -= acircle[y-pos.y+radius];
            }
            int lx1 = max(pos.x - xoffs, 0);
            int lx2 = min(pos.x + xoffs + 1, mSize.x);
            if (!(lx1 < lx2))
                continue;
            int pl = y*mSize.x + lx1;
            Lexel* data = &mLevelData[pl];
            int count_y = count;
            int max_x = lx2 - pos.x;
            for (int x = lx1 - pos.x; x < max_x; x++) {
                auto d = *data;
                if (d != 0) {
                    bits |= d;
                    d_x += x;
                    count++;
                }
                data++;
            }
            //count_y pixels in this scanline; add them to the vector
            count_y = count - count_y;
            d_y += (y - pos.y) * count_y;
        }

        out_dir = -Vector2i(d_x, d_y);
        out_count = count;
        out_bits = bits;
    }

    /*
     * Return an array, which contains in for each Y-value the X-value of the
     * first point of a filled circle... The Y-value is the index into the
     * array.
     * The circle has the diameter 1+radius*2
     * No real reason for that, but the code above becomes simpler if circle is
     * precalculated (and it also becomes slower...).
     */
    //public for some other debugging code, actually private
    final int[] getCircle(int radius) {
        assert(radius >= 0);

        if (radius >= mCircles.length) {
            //xxx clamp to a maximum for more robustness
            mCircles.length = radius+1;
        }

        auto c = mCircles[radius];
        if (c.length)
            return c;

        int[] stuff = new int[radius*2+1];
        drawing.circle(radius, radius, radius,
            (int x1, int x2, int y) {
                stuff[y] = x1;
            });
        mCircles[radius] = stuff;
        return stuff;
    }

    //draw a bitmap, but also modify the level pixels
    //where (metadata & meta_mask) == meta_cmp, copy a pixel and set
    //  pixel-metadata to "after"
    void drawBitmap(Vector2i p, Surface source, Vector2i size,
        ubyte meta_mask, ubyte meta_cmp, Lexel after)
    {
        argcheck(!mDataOnly, "Not for data-only renderer");

        //clip
        size.x = min(size.x, source.size.x);
        size.y = min(size.y, source.size.y);
        int cx1 = max(p.x, 0);
        int cy1 = max(p.y, 0);
        int cx2 = min(mSize.x, p.x+size.x);  //exclusive
        int cy2 = min(mSize.y, p.y+size.y);
        assert(cx2-cx1 <= size.x);
        assert(cy2-cy1 <= size.y);
        if (cx1 >= cx2 || cy1 >= cy2)
            return;

        scope pixels = new PixelAccess();

        Color.RGBA32* data; size_t pitch;
        source.lockPixelsRGBA32(data, pitch);

        for (int y = cy1; y < cy2; y++) {
            //offset to relevant start of source scanline
            Color.RGBA32* src = data + pitch*(y-p.y) + (cx1-p.x);
            Lexel* dst_meta = &mLevelData[mSize.x*y+cx1];
            auto iter = pixels.get_iter(y, cx1, cx2);
            while (iter.x < iter.x2) {
                if (!pixelIsTransparent(src)
                    && ((*dst_meta & meta_mask) == meta_cmp))
                {
                    *dst_meta = after;
                    //actually copy pixel
                    *iter.px = *src;
                }
                src++; dst_meta++;
                iter.next_x();
            }
        }

        auto change = Rect2i(cx1, cy1, cx2, cy2);
        pixels.done(change);
        source.unlockPixels(Rect2i.init);

        previewUpdate(change);
    }

    //the checksum includes only the data
    //(the image doesn't matter for the game, as only the "data" is used for
    //  collision testing; further, image saving and reloading with colorkeyed
    //  images may change the color value for transparent pixels)
    string checksum() {
        Digest hash = new MD5();
        hash.update(cast(void[])mLevelData);
        return hash.hexDigest();
    }
}


