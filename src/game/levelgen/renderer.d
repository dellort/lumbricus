module game.levelgen.renderer;

//This module only renders auto-generated levels.
//It smoothes and draws the polygons generated by genrandom.d and also
//texturizes them.
//Also handles collision and in-game modification of the landscape.

import game.levelgen.landscape;
import framework.framework;
import utils.vector2;
import utils.time;
import utils.mylist;
import utils.log;
import utils.misc;
import drawing = utils.drawing;
import math = std.math;

import std.stdio;

debug import utils.perf;

public alias Vector2f Point;

//don't know where to put this, moved it out of blastHole() because this thing
//affects the bitmap modification bounding box
const int cBlastBorder = 4;

class LandscapeBitmap {
    private uint mWidth, mHeight;
    private Surface mImage;
    private Lexel[] mLevelData;
    private Log mLog;

    //blastHole: Distance from explosion outer circle to inner (free) circle
    private const int cBlastCenterDist = 25;

    private int[][] mCircles; //getCircle()

    //because I'm stupid, I'll store all points into a linked lists to be able
    //to do naive corner cutting by subdividing the curve recursively
    private struct Vertex {
        Point pt;
        bool no_subdivide = false;
        mixin ListNodeMixin;
    }
    private alias List!(Vertex*) VertexList;

    //steps = number of subdivisions
    //start = start of the subdivision
    private static void cornercut(VertexList verts, int steps, float start) {
        for (int i = 0; i < 5; i++) {
            if (!verts.hasAtLeast(3))
                return;
            Vertex* cur = verts.head;
            Point pt = cur.pt;
            do {
                Vertex* next = verts.ring_next(cur);
                Vertex* overnext = verts.ring_next(next);
                if (!cur.no_subdivide && !next.no_subdivide) {
                    Vertex* newv = new Vertex();
                    verts.insert_after(newv, cur);
                    Point p2 = next.pt, p3 = overnext.pt;
                    newv.pt = pt + (p2-pt)*(1.0f - start);
                    pt = p2;
                    p2 = p2 + (p3-p2)*start;
                    next.pt = p2;
                } else {
                    pt = next.pt;
                }
                cur = next;
            } while (cur !is verts.head);
        }
    }

    //draw a polygon; it's closed by the line points[$-1] - points[0]
    //"marker" is the value that should be written into the Level.mData array,
    //if a pixel is coverered by this polygon
    //subdiv: if subdivision should be done
    //"visible" is true if the polygon should appear in the image surface
    //nosubdiv: indices for points that start lines which shouldn't be
    //  "interpolated" (they won't be changed)
    //"texture" is used to fill the new polygon, if it is null, make all pixels
    //  covered by the polygon transparent
    //historical note: points was changed from Vector2f
    public void addPolygon(Vector2i[] points, bool visible,
        Vector2i texture_offset, Surface texture, Lexel marker,
        bool subdiv, uint[] nosubdiv, int subdivSteps, float subdivStart)
    {
        if (!visible)
            return;

        VertexList vertices = new VertexList(Vertex.getListNodeOffset());

        uint curindex = 0;
        foreach(Vector2i p; points) {
            Vertex* v = new Vertex();
            v.pt = toVector2f(p);
            //obviously, nosubdiv should be small
            foreach(uint index; nosubdiv) {
                if (index == curindex)
                    v.no_subdivide = true;
            }
            vertices.insert_tail(v);
            curindex++;
        }

        if (subdiv) {
            cornercut(vertices, subdivSteps, subdivStart);
        }

        Point[] urgs;
        urgs.length = vertices.count;
        urgs.length = 0;
        foreach(Vertex* v; vertices) {
            urgs ~= v.pt;
        }

        delete vertices;

        //also not good and nice
        uint tex_pitch, tex_w, tex_h;
        void* tex_data;
        uint plain_evil;

        if (texture !is null) {
            texture.lockPixelsRGBA32(tex_data, tex_pitch);
            tex_w = texture.size.x;
            tex_h = texture.size.y;
        } else {
            //simulate an image consisting of a single transparent pixel
            plain_evil = mImage.colorkey.toRGBA32();
            tex_data = &plain_evil;
            tex_w = tex_h = 1;
            tex_pitch = 4;
        }

        int tex_offset_x = texture_offset.x;
        int tex_offset_y = texture_offset.y;

        void* dstptr; uint dstpitch;
        mImage.lockPixelsRGBA32(dstptr, dstpitch);

        void drawScanline(int y, int x1, int x2) {
            assert(x1 <= x2);
            assert(y >= 0 && y < mHeight);
            //clipping (maybe rasterizePolygon should do that)
            if (x2 < 0 || x1 >= mWidth)
                return;
            if (x1 < 0)
                x1 = 0;
            if (x2 > mWidth)
                x2 = mWidth;
            uint ty = (y + tex_offset_y) % tex_h;
            uint* dst = cast(uint*)(dstptr +  y*dstpitch + x1*uint.sizeof);
            uint* texptr = cast(uint*)(tex_data + ty*tex_pitch);
            Lexel* markerptr = &mLevelData[y*mWidth+x1];
            for (uint x = x1; x < x2; x++) {
                if (visible) {
                    uint* texel = texptr + (x + tex_offset_x) % tex_w;
                    *dst = *texel;
                }

                *markerptr = marker;

                dst++;
                markerptr++;
            }
        }

        debug {
            auto counter = new PerfTimer(true);
            counter.start();
        }

        rasterizePolygon(mWidth, mHeight, urgs, false, &drawScanline);

        debug {
            counter.stop();
            mLog("render.d: polygon rendered in %s", counter.time);
        }

        mImage.unlockPixels(Rect2i(Vector2i(0), mImage.size));
        if (texture !is null) {
            texture.unlockPixels(Rect2i.init);
        }
    }

    //for RGBA32 format, check if pixel is considered to be transparent
    //hopefully inlined
    private bool is_not_transparent(uint c) {
        //ultra slow!
        return !mImage.isTransparent(c);
        //return !!(c & 0xff000000);
        //xxx this sucks!
        //return (c & 0xff00ff) != 0xff00ff;
    }

    //it's a strange design decision to do it _that_ way. sorry for that.
    //draw a border in "a", using that texture, where "a" forms a border to "b"
    //draws top and bottom borders with different textures (if do_xx is set,
    //tex_xx must be valid)
    //  "do_up":   draw bottom border with texture "tex_up"
    //  "do_down": draw top border with texture "tex_down"
    public void drawBorder(Lexel a, Lexel b, bool do_up, bool do_down,
        Surface tex_up, Surface tex_down)
    {
        //it always scans in the given direction; to draw both borders where "a"
        //is on top ob "b" and where "b" is on top of "a", you have to call this
        //twice (which isn't a problem, since you might want to use different
        //textures for this)
        //"up": false=scan up-to-down, true=scan down-to-up ("a" und "b" are
        // also checked in that order)
        //"texture" must not be null
        void drawBorderInt(Lexel a, Lexel b, bool up, Surface texture,
            ubyte[] tmpData)
        {
            int dir = up ? -1 : +1;

            uint tex_pitch;
            void* tex_data;
            texture.lockPixelsRGBA32(tex_data, tex_pitch);
            uint tex_w = texture.size.x;
            uint tex_h = texture.size.y;
            uint* texptr = cast(uint*)tex_data;

            uint dsttransparent = mImage.colorkey.toRGBA32();

            void* dstptr; uint dstpitch;
            mImage.lockPixelsRGBA32(dstptr, dstpitch);

            ubyte[] apline = new ubyte[mWidth]; //initialized to 0
            int start = up ? mHeight-1 : 0;
            for (int y = start; y >= 0 && y <= mHeight-1; y += dir) {
                uint* scanline = cast(uint*)(dstptr + y*dstpitch);
                Lexel* meta_scanline = &mLevelData[y*mWidth];
                ubyte* poldline = &tmpData[y*mWidth];
                ubyte* ppline = &apline[0];
                for (int x = 0; x < mWidth; x++) {
                    //the data written into ppline is used by the next pass in
                    //the other direction
                    ubyte pline = *ppline;

                    if (*meta_scanline == a) {
                        if (pline == 0xFF)
                            pline = tex_h+1;
                        if (pline > 0)
                            pline -= 1;
                    } else if (*meta_scanline == b) {
                        pline = 0xFF;
                    } else {
                        pline = 0;
                    }

                    *ppline = pline;

                    //set the pixel accordingly
                    //comparison with *oldpline ensures that up and down texture
                    //use the same part of the available space
                    if (pline > 0 && pline < 0xFF && pline > *poldline) {
                        uint* texel = texptr + x%tex_w;
                        uint texy = (tex_h-pline)%tex_h;
                        texel = cast(uint*)(cast(void*)texel + texy*tex_pitch);
                        if (!texture.isTransparent(*texel))
                            *scanline = *texel;
                        else {
                            //XXX assumption: parts of the texture that should
                            //render transparent only take half of the y space
                            if (texy < tex_h/2) {
                                //set current pixel transparent
                                *scanline = dsttransparent;
                                *meta_scanline = Lexel.Null;
                            }
                        }
                    }

                    scanline++;
                    meta_scanline++;
                    ppline++;
                    poldline++;
                }
                //save current pline for next pass in other direction
                tmpData[y*mWidth..(y+1)*mWidth] = apline;
            }

            delete apline;

            mImage.unlockPixels(Rect2i(Vector2i(0), mImage.size));
            texture.unlockPixels(Rect2i.init);
        }

        debug {
            auto counter = new PerfTimer(true);
            counter.start();
        }

        //stores temporary data between up and down pass
        ubyte[] tmp = new ubyte[mWidth*mHeight];

        if (do_down)
            drawBorderInt(a, b, false, tex_down, tmp);
        if (do_up)
            drawBorderInt(a, b, true, tex_up, tmp);

        delete tmp;

        debug {
            counter.stop();
            mLog("render.d: border drawn in %s", counter.time());
        }
    }

    //render a circle on the surface
    // w, h: source bitmap width and height
    // meta_mask, meta_cmp: actually copy pixel if (meta & mask) == cmp
    // meta_domask: after checking and copying the pixel, mask meta with this
    //I put it all into this to avoid code duplication
    //called in-game!
    private void circle_masked(Vector2i pos, int radius, void* dst,
        uint dst_pitch, void* src, uint src_pitch, uint w, uint h,
        ubyte meta_mask, ubyte meta_cmp, ubyte meta_domask = 255)
    {
        assert(radius >= 0);
        auto st = pos;
        int[] circle = getCircle(radius);

        for (int y = -radius; y <= radius; y++) {
            int ly = st.y + y;
            if (ly < 0 || ly >= mHeight)
                continue;
            int xoffs = radius - circle[y+radius];
            int x1 = st.x - xoffs;
            int x2 = st.x + xoffs + 1;
            //clipping
            x1 = x1 < 0 ? 0 : x1;
            x1 = x1 > mWidth ? mWidth : x1;
            x2 = x2 < 0 ? 0 : x2;
            x2 = x2 > mWidth ? mWidth : x2;
            uint* dstptr = cast(uint*)(dst+dst_pitch*ly);
            uint* srcptr = cast(uint*)(src+src_pitch*(ly % h));
            dstptr += x1;
            Lexel* meta = mLevelData.ptr + mWidth*ly + x1;
            for (int x = x1; x < x2; x++) {
                bool set = ((*meta & meta_mask) == meta_cmp);
                /+bool set = ((((*meta & Lexel.SolidSoft) == 0) ^ paintOnSolid)
                    & !(*meta & Lexel.SolidHard));+/
                /+ same code without if, hehe
                uint mask = cast(uint)set - 1;
                uint rcolor = *(srcptr+(x & swl));
                *dstptr = (*dstptr & mask) | (rcolor & ~mask);
                +/
                if (set) {
                    *dstptr = *(srcptr+(x % w));
                }
                //yes, unconditionally
                *meta &= meta_domask;
                dstptr++;
                meta++;
            }
        }
    }

    //destroy a part of the landscape
    //called in-game!
    //  pos = center of the damage
    //  radius = radius of the circle around pos making up the now free area
    //  blast_border = added to radius for the area of the solid but modified
    //     area (on the border, the image is changed, but not the metadata) is
    //     pixels outside the circle (radius+blast_border) aren't touched)
    //  theme = bitmaps to use as background etc. (can be null)
    public void blastHole(Vector2i pos, int radius, int blast_border,
        LandscapeTheme theme = null)
    {
        const ubyte cAllMeta = Lexel.SolidSoft | Lexel.SolidHard;

        assert(radius >= 0);
        assert(blast_border >= 0);

        uint col;

        void* pixels; uint pitch;
        mImage.lockPixelsRGBA32(pixels, pitch);

        auto nradius = max(radius - cBlastCenterDist,0);

        //call circle_masked(), with either the Surface s or the Color c
        //if s !is null, only the surface is used, else use the color
        void doCircle(int radius, Surface s, Color c, ubyte meta_mask,
            ubyte meta_cmp, ubyte meta_domask = 255)
        {
            void* srcpixels; uint srcpitch;
            int sx, sy;
            if (s) {
                s.lockPixelsRGBA32(srcpixels, srcpitch);
                sx = s.size.x; sy = s.size.y;
            } else {
                //plain evil etc.: simulate a 1x1 bitmap with the color in it
                int col = c.toRGBA32();
                srcpixels = &col;
                srcpitch = 4;
                sx = 1; sy = 1;
            }
            circle_masked(pos, radius, pixels, pitch, srcpixels, srcpitch, sx,
                sy, meta_mask, meta_cmp, meta_domask);
            if (s) {
                s.unlockPixels(Rect2i.init);
            }
        }

        //draw the background image into the area to be destroyed
        //actually, you can only see a ring of that background image; the center
        //of the destruction is free landscape (except for SolidHard pixels)
        //the center is cleared later to achieve this
        //in the same call, mask all pixels with SolidHard to remove any
        //SolidSoft pixels...
        doCircle(radius, theme ? theme.backImage : null,
            theme ? theme.backColor : Color(0,0,0),
            cAllMeta, Lexel.SolidSoft, Lexel.SolidHard);

        int blast_radius = radius + blast_border;

        //draw that funny border; the border is still solid and also is drawn on
        //solid ground only (except for SolidHard pxiels: they stay unchanged)
        //because all SolidSoft pixels were cleared above, only the remaining
        //landscape around the destruction will be coloured with this border...
        if (theme) {
            doCircle(blast_radius, theme.borderImage, theme.borderColor,
                cAllMeta, Lexel.SolidSoft);
        }

        if (nradius > 0) {
            //clear the center of the destruction (to get rid of that background
            //texture)
            doCircle(nradius, null, mImage.colorkey(), cAllMeta, 0);
        }

        Rect2i bb;
        bb.p1 = pos - Vector2i(blast_radius);
        bb.p2 = pos + Vector2i(blast_radius);
        mImage.unlockPixels(bb);
    }

    //calculate normal at that position
    //this is (very?) expensive
    //maybe replace it by other methods as used by other worms clones
    // circle = if true check a circle, else a quad, with sides (radius*2+1)^2
    // dir = not-notmalized diection which points to the outside of the level
    // count = number of colliding pixels
    public void checkAt(Vector2i pos, int radius, bool circle, out Vector2i dir,
        out int count)
    {
        assert(radius >= 0);
        //xxx: I "optimized" this, the old version is still in r451

        auto st = pos;
        int[] acircle = circle ? getCircle(radius) : null;

        //dir and count are initialized with 0

        int ly1 = max!(int)(st.y - radius, 0);
        int ly2 = min!(int)(st.y + radius + 1, mHeight);
        for (int y = ly1; y < ly2; y++) {
            int xoffs = radius;
            if (circle) {
                 xoffs -= acircle[y-st.y+radius];
            }
            int lx1 = max!(int)(st.x - xoffs, 0);
            int lx2 = min!(int)(st.x + xoffs + 1, mWidth);
            int pl = y*mWidth + lx1;
            for (int x = lx1; x < lx2; x++) {
                if (mLevelData[pl] != 0) {
                    dir += Vector2i(x, y) - pos;
                    count++;
                }
                pl++;
            }
        }

        dir = -dir;
    }

    /*
     * Return an array, which contains in for each Y-value the X-value of the
     * first point of a filled circle... The Y-value is the index into the
     * array.
     * The circle has the diameter 1+radius*2
     * No real reason for that, but the code above becomes simpler if circle is
     * precalculated (and it also becomes slower...).
     */
    private int[] getCircle(int radius) {
        assert(radius >= 0);

        if (radius >= mCircles.length) {
            //xxx clamp to a maximum for more robustness
            mCircles.length = radius+1;
        }

        auto c = mCircles[radius];
        if (c.length)
            return c;

        int[] stuff = new int[radius*2+1];
        drawing.circle(radius, radius, radius,
            (int x1, int x2, int y) {
                stuff[y] = x1;
            });
        mCircles[radius] = stuff;
        return stuff;
    }

    //oh yeah, manual bitmap drawing code!
    private void doDrawBmp(int px, int py, Surface source, int w, int h,
        ubyte meta_mask, ubyte meta_cmp, Lexel after)
    {
        //clip
        w = min(w, source.size.x);
        h = min(h, source.size.y);
        int cx1 = max(px, 0);
        int cy1 = max(py, 0);
        int cx2 = min!(int)(mWidth, px+w);  //exclusive
        int cy2 = min!(int)(mHeight, py+h);
        assert(cx2-cx1 <= w);
        assert(cy2-cy1 <= h);
        if (cx1 >= cx2 || cy1 >= cy2)
            return;

        void* data; uint pitch;
        source.lockPixelsRGBA32(data, pitch);
        void* dstptr; uint dstpitch;
        mImage.lockPixelsRGBA32(dstptr, dstpitch);

        for (int y = cy1; y < cy2; y++) {
            //offset to relevant start of source scanline
            uint* src = cast(uint*)(data + pitch*(y-py) + (cx1-px)*uint.sizeof);
            uint* dst = cast(uint*)(dstptr + dstpitch*y + cx1*uint.sizeof);
            Lexel* dst_meta = &mLevelData[mWidth*y+cx1];
            for (int x = cx1; x < cx2; x++) {
                if (!source.isTransparent(*src)
                    && ((*dst_meta & meta_mask) == meta_cmp))
                {
                    *dst_meta = after;
                    //actually copy pixel
                    *dst = *src;
                }
                src++; dst++; dst_meta++;
            }
        }

        mImage.unlockPixels(Rect2i(cx1, cy1, cx2, cy2));
        source.unlockPixels(Rect2i.init);
    }

    //draw a bitmap, but also modify the level pixels
    //where (metadata & meta_mask) == meta_cmp, copy a pixel and set
    //pixel-metadata to "after"
    public void drawBitmap(Vector2i p, Surface source, Vector2i size,
        ubyte meta_mask, ubyte meta_cmp, Lexel after)
    {
        //ewww what has this become
        doDrawBmp(p.x, p.y, source, size.x, size.y, meta_mask, meta_cmp, after);
    }

    /+
    untested... unneeded?
    //same as above, but only draw a sub region of the source bitmap
    // p == uper right corner in destination
    // sp == upper right corner in source bitmap
    public void drawBitmap(Vector2i p, Surface source, Vector2i sp,
        Vector2i size, Lexel before, Lexel after)
    {
        size.x = min(size.x + sp.x, source.size.x) - sp.x;
        size.y = min(size.y + sp.y, source.size.y) - sp.y;
        void* data, uint pitch;
        source.lockPixelsRGBA32(data, pitch);
        //xxx: hm, more clipping to make it robust?
        void* ndata = data + sp.y*pitch + sp.x*uint.sizeof;
        doDrawBmp(p.x, p.y, ndata, pitch, size.x, size.y, before, after);
        source.unlockPixels();
    }
    +/

    //under no cirumstances change pixelformat or size of this
    public Surface image() {
        return mImage;
    }

    public this(Vector2i size) {
        mImage = gFramework.createSurface(size, Transparency.Colorkey);
        mImage.fill(Rect2i(mImage.size), mImage.colorkey());
        this(mImage, false);
    }

    //copy the level bitmap and per-pixel-metadata
    public this(Surface bmp, Lexel[] a_data, bool copy = true) {
        this(copy ? bmp.clone() : bmp, false);
        //xxx: don't copy
        mLevelData[] = a_data;
    }

    LandscapeBitmap copy() {
        return new LandscapeBitmap(mImage, mLevelData);
    }

    //create a new Landscape which contains a copy of a subrectangle of this
    LandscapeBitmap cutOutRect(Rect2i rc) {
        rc.fitInsideB(Rect2i(mImage.size()));
        //copy out the subrect from the metadata
        if (!rc.isNormal())
            return null; //negative sizes duh
        Lexel[] ndata;
        ndata.length = rc.size.x * rc.size.y;
        uint sx = rc.size.x;
        int o1 = 0;
        int o2 = rc.p1.y*mWidth + rc.p1.x;
        for (int y = 0; y < rc.size.y; y++) {
            ndata[o1 .. o1 + sx] = mLevelData[o2 .. o2 + sx];
            o1 += sx;
            o2 += mWidth;
        }
        return new LandscapeBitmap(mImage.subrect(rc), ndata, false);
    }

    //create from a bitmap; also used as common constructor
    //bmp = the landscape-bitmap, must not be null
    //import_bmp = create the metadata from the image's transparency information
    //      if false, initialize metadata with Lexel.init
    //memory managment: you shall not touch the Surface instance in bmp anymore
    public this(Surface bmp, bool import_bmp = true) {
        mImage = bmp;

        mWidth = mImage.size.x;
        mHeight = mImage.size.y;
        mLevelData.length = mWidth*mHeight;

        mLog = registerLog("levelrenderer");

        //create mask

        if (!import_bmp)
            return;

        void* ptr; uint pitch;
        mImage.lockPixelsRGBA32(ptr, pitch);

        for (int y = 0; y < mHeight; y++) {
            uint* pixel = cast(uint*)(ptr + y*pitch);
            Lexel* meta = &mLevelData[y*mWidth];
            for (int x = 0; x < mWidth; x++) {
                *meta = is_not_transparent(*pixel) ? Lexel.SolidSoft
                    : Lexel.Null;
                meta++;
                pixel++;
            }
        }

        mImage.unlockPixels(Rect2i.init);
    }

    public void free() {
        mImage.free();
    }

    public Surface releaseImage() {
        auto img = mImage;
        mImage = null;
        return img;
    }

    public Vector2i size() {
        return mImage.size;
    }

    public Lexel[] levelData() {
        return mLevelData;
    }
}


//rasterizePolygon(): completely naive Y-X polygon rasterization algorithm
//the polygon is defined by the items of "points", it's implicitely closed with
//the edge (points[$-1], points[0])
//no edges must intersect with each other
//the algorithm also could handle several polygons (as long as they don't
//intersect), but I didn't need that functionality

//NOTE: The even-odd filling rule is used; and somehow the usual corner-cases
//  don't (seem to) happen (because the edges are removed from the active edge
//  list before the edges join each other, so to say). Maybe there's also input
//  data for which the current implementation outputs garbage...

private struct Edge {
    int ymax;
    double xmin;
    double m1;
    Edge* next; //next in scanline or AEL
}

private int myround(float f) {
    return cast(int)(f+0.5f);
}

private void rasterizePolygon(uint width, uint height, Vector2f[] points,
    bool invert, void delegate (int y, int x1, int x2) renderScanline)
{
    if (points.length < 3)
        return;

    //note: leave entries in per_scanline[y] unsorted
    //I sort them inefficiently when inserting them into the AEL
    Edge*[] per_scanline;
    per_scanline.length = height;

    //convert points array and create Edge structs and insert them
    void add_edge(in Vector2f a, in Vector2f b) {
        Edge* edge = new Edge();

        bool invert = false;
        if (a.y > b.y) {
            a.swap(b);
            invert = true;
        }

        int ymin = myround(a.y);
        edge.ymax = myround(b.y);

        //throw away horizontal segments or if not visible
        if (edge.ymax == ymin || edge.ymax < 0 || ymin >= cast(int)height) {
            return;
        }

        auto d = b-a;
        edge.m1 = cast(double)d.x / d.y; //x increment for each y increment

        if (ymin < 0) {
            //clipping, xxx: seems to work, but untested
            a.x = a.x += edge.m1*(-ymin);
            a.y = 0;
            ymin = 0;
        }
        assert(ymin >= 0);

        edge.xmin = a.x;

        if (ymin >= height)
            return;

        edge.next = per_scanline[ymin];
        per_scanline[ymin] = edge;
    }

    for (uint n = 0; n < points.length-1; n++) {
        add_edge(points[n], points[n+1]);
    }
    add_edge(points[$-1], points[0]);

    //umm, I wonder if this trick always works
    if (invert) {
        add_edge(Vector2f(0, 0), Vector2f(0, height));
        add_edge(Vector2f(width, 0), Vector2f(width, height));
    }

    Edge* ael;
    Edge* resort_edges_first;
    Edge* resort_edges_last;

    for (uint y = 0; y < height; y++) {
        //copy new edges into the AEL
        Edge* newedge = per_scanline[y];

        //somewhat hacky way to resort something
        if (resort_edges_last) {
            resort_edges_last.next = newedge;
            newedge = resort_edges_first;
            resort_edges_first = resort_edges_last = null;
        }

        while (newedge) {
            Edge* next = newedge.next;
            newedge.next = null;

            //AEL must be sorted, so that e1.xmin <= e2.xmin etc.
            //since edges that are inserted can have the same starting-
            //point, use the increased value
            //all my approaches to keep the AEL sorted failed (numeric problems)
            //  so resort the AEL as soon as the sorting condition is violated
            Edge** ptr = &ael;
            while (*ptr && (*ptr).xmin < newedge.xmin) {
                ptr = &(*ptr).next;
            }
            newedge.next = *ptr;
            *ptr = newedge;

            newedge = next;
        }

        //delete old edges
        Edge** cur = &ael;
        while (*cur) {
            if (y >= (*cur).ymax) {
                *cur = (*cur).next;
            } else {
                cur = &(*cur).next;
            }
        }

        if (ael is null)
            continue;

        //draw and advance
        Edge* edge = ael;
        uint r = 0;
        bool c = false;
        Edge* last;
        float last_xmin;
        bool need_resort = false;
        while (edge) {
            if (last) {
                assert(last_xmin <= edge.xmin);
                if (last_xmin > edge.xmin) {
                    renderScanline(y, myround(last.xmin-last.m1),
                        myround(edge.xmin));
                }
            }
            c = !c;
            assert(y <= edge.ymax);
            if (last && !c) {
                renderScanline(y, myround(last.xmin-last.m1),
                    myround(edge.xmin));
            }
            //advance
            last_xmin = edge.xmin;
            edge.xmin += edge.m1;
            if (last && last.xmin > edge.xmin)
                need_resort = true;
            last = edge;
            edge = edge.next;
            r++;
        }
        if (need_resort) {
            resort_edges_first = ael;
            resort_edges_last = last;
            ael = null;
        }
    }
}
