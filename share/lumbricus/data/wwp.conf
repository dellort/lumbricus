//for using the original WWP graphics
require_resources {
    "mainspr.conf"
    "sounds.conf"

    //GUI elements... move into different ResourceSet?
    //(server doesn't need them)
    "windmeter.conf"
}

//this was sky.conf, moved to here because it's graphicset specific
resources {
    bitmaps {
        border_segment = "border_segment.png"
        //for worm platforms, when placing is unsuccessful
        place_platform = "level/gpl/bridge/bridge.png"
    }
    music {
        //pick your own
        game = "music.ogg"
    }
}
sky {
    //list of animation resources for the clouds
    clouds {
        "cloud1"
        "cloud2"
        "cloud3"
    }
}

//maybe shouldn't be there (but was easier for code structure)
//links to the "sprite" things (for game.d/sprite.d)
sprites {
    //config files (filename without ".conf")
    "worm"
    "crate"
    "grave"
    "barrel"
}

explosions {
    shockwave1 {
        "expl_outer_size1"
        "expl_outer_size2"
        "expl_outer_size3"
        "expl_outer_size4"
    }
    shockwave2 {
        "expl_inner_size1"
        "expl_inner_size2"
        "expl_inner_size3"
        "expl_inner_size4"
    }
    comictext {
        "expl_biff"
        "expl_poot"
        "expl_pow"
        "expl_foom"
    }
    smoke {
        "smoke_white_size1"
        "smoke_white_size2"
        "smoke_white_size3"
        "smoke_white_size4"
    }
    sizetreshold { "25" "100" "150" "200" }
}

//used to load the Sequence stuff, works similar to animations.txt
sequences {
    //each item is sequence

    s_worm {
        //each item is a sequence state
        //below, the "walk" state shows, how a simple sequence state type is
        //  used (type = "simple_animation"). this state type maps directly to
        //  an animation, using the animation's p1 for the sprite rotation.
        //the "stand" types shows a complex sequence state type. the type is
        //  indicated by the "type" node. the value of this node is used to find
        //  the loader, and the loader might do arbitrary things with the node.

        //for simple states with just an animation
        walk = "worm_walk"
        walk_blowtorch = "worm_walk_blowtorch"
        fly_fall = "worm_fall"
        fly_slide = "worm_slide"
        fly_roll = "worm_roll"
        fly_heavy = "worm_heavy_fly"
        jump_normal = "worm_jump"
        jump_backflip = "worm_jump_back"
        drown = "worm_drown"
        win = "worm_win"
        rope = "worm_rope"
        drill = "worm_usedrill"

        die = "worm_die"
        beaming = "worm_beaming"
        reverse_beaming = "worm_beaming_backwards"
        bounce_minor = "worm_wiggle1"
        bounce_major = "worm_wiggle2"
        jump_start = "worm_jump_enter"
        jump_to_fall = "worm_jump_to_fall"

        //stand is quite special, because it needs to select weapon animations
        stand {
            //loader type
            type = "wwp_weapon_select"

            //normal animation with no weapon selected
            animation = "worm_stand"

            //animations when a weapon is selected
            //WWP just works like this way: a worm is always a single animation,
            //  and the weapons are blended into the normal "stand" state
            //the job of the "wwp_worm_stand" thing is to select the correct
            //  animation based on the weapon
            weapons {
                //map weapon names to animations
                //  weapon_name = "animation_resource"
                //there are various animation states with weapons, and one can
                //  use this to select animations:
                //  holy = "worm_holy_+"
                //it will replace '+' by get, hold and fire; if hold or fire are
                //  not found, these animations are left out; if get is not
                //  found, worm_no_weapon_get is used ("get" from "#unknown")
                //animation types:
                //  get: played once when the weapon is selected
                //  hold: played after get is finished (only reason for this is
                //      because get usually can't show arbitrary weapon angles,
                //      but hold can)
                // [unget: doesn't exist, instead get is played backwards]
                //  fire: played on repeat when firing (if firing has no time
                //      duration (baseball bat?), the animation is played once)
                // [fire_end: when firing is finished; this will be played
                //      instead of unget, if it exists]
                //xxx: what else should be possible?

/++
                //lololo macro processing
                //turn each entry % from stuff into:
                //  weapon_% = "worm_%_+"
                + "!inline:minid" = <#:
                    local stuff = [
                        "atomtest",
                        "beamer",
                        "dynamite",
                        "airstrike",
                        "mingvase",
                        "mine",
                        "granny",
                        "sally_army",
                        "cow",
                        "sheep",
                        "prod",
                        "axe",
                        "drill",

                        "holy",
                        "banana",
                        "bazooka",
                        "cluster",
                        "grenade",
                        "homing",
                        "sheeplauncher",
                        "minigun",
                        "molotov",
                        "pistol",
                        "shotgun",
                        "uzi",
                        "mortar",
                        "rope",
                        "flamethrower",
                        "skipturn",
                        "surrender",
                        "baseball",
                        "blowtorch",

                        //actually unused
                        "helmet",
                        "skunk",
                        "mole",
                        "headband",
                        "freezer",
                        "hat",
                    ]

                    foreach (x; stuff) {
                        emit_text(format(
                            `+ "weapon_{0}" = "worm_{0}_+"
                            `, x))
                    }
                #>
++/

                //-------------------
                weapon_atomtest = "worm_atomtest_+"
                weapon_beamer = "worm_beamer_+"
                weapon_dynamite = "worm_dynamite_+"
                weapon_airstrike = "worm_airstrike_+"
                weapon_mingvase = "worm_mingvase_+"
                weapon_mine = "worm_mine_+"
                weapon_granny = "worm_granny_+"
                weapon_sally_army = "worm_sally_army_+"
                weapon_cow = "worm_cow_+"
                weapon_sheep = "worm_sheep_+"
                weapon_prod = "worm_prod_+"
                weapon_axe = "worm_axe_+"
                weapon_drill = "worm_drill_+"
                weapon_holy = "worm_holy_+"
                weapon_banana = "worm_banana_+"
                weapon_bazooka = "worm_bazooka_+"
                weapon_cluster = "worm_cluster_+"
                weapon_grenade = "worm_grenade_+"
                weapon_homing = "worm_homing_+"
                weapon_sheeplauncher = "worm_sheeplauncher_+"
                weapon_minigun = "worm_minigun_+"
                weapon_molotov = "worm_molotov_+"
                weapon_pistol = "worm_pistol_+"
                weapon_shotgun = "worm_shotgun_+"
                weapon_uzi = "worm_uzi_+"
                weapon_mortar = "worm_mortar_+"
                weapon_rope = "worm_rope_+"
                weapon_flamethrower = "worm_flamethrower_+"
                weapon_skipturn = "worm_skipturn_+"
                weapon_surrender = "worm_surrender_+"
                weapon_baseball = "worm_baseball_+"
                weapon_blowtorch = "worm_blowtorch_+"
                weapon_helmet = "worm_helmet_+"
                weapon_skunk = "worm_skunk_+"
                weapon_mole = "worm_mole_+"
                weapon_headband = "worm_headband_+"
                weapon_freezer = "worm_freezer_+"
                weapon_hat = "worm_hat_+"
                //-------------------

                //special name for weapons that couldn't be found in this list
                + "#unknown" = "worm_no_weapon_+"
            }

            //purely graphics based idle animations
            //wait time for idle animation
            idle_wait = "7.5s:30s"
            //list of idle animations (random pick)
            //xxx: need to sort out idle animations; maybe some animations also
            //  depend from the "mood" of the worm, or whatever
            idle_animations {
                "worm_apple"
                "worm_scratch"
                "worm_confused"
                //"worm_sniff"  //this is for ill worms and doesn't fit to normal sit animation
                "worm_look2"
                "worm_mustache"
                "worm_pout"
                "worm_blink_down"
                "worm_blink_up"
                "worm_cool"
                "worm_look_up"
                "worm_look1"
                "worm_look3"
                "worm_wtf"
                "worm_blink_back"
                "worm_swearing"
                "worm_blink"
            }
        }

        //generates a single state with the given name
        jetpack {
            type = "wwp_jetpack"

            normal = "worm_jet"
            enter = "worm_jetpack_enter"
            turn = "worm_jet_turn"
            flame_x = "worm_jet_ex_h"
            flame_y = "worm_jet_ex_v"
        }

    }

    s_crate_weapon {
        normal = "crate1"
        fly = "crate1_fly"
        drown = "crate1_drown"
        beam = "crate1_beam"
    }

    s_crate_med {
        normal = "crate2"
        fly = "crate2_fly"
        drown = "crate2_drown"
        beam = "crate2_beam"
    }

    s_crate_tool {
        normal = "crate3"
        fly = "crate3_fly"
        drown = "crate3_drown"
        beam = "crate3_beam"
    }

    s_mine {
        normal = "mine"
        flashing = "mine_flashing"
        drown = "mine_drown"
    }

    s_barrel {
        //goes white with damage
        //p2 of the animation is connected with the sprite health point value
        normal {
            type = "simple_animation"
            wire_p2_to_damage = "true"
            animation = "barrel"
        }

        //under water
        drown = "barrel_drown"
    }

/++
    + "!inline:minid" = <!:
        //e.g. "holy _fly" => s_holy with holy_fly and holy_drown
        local stuff = [
            "holy _fly",
            "banana _fly",
            "bazooka _fly",
            "clustershard",
            "cluster _fly",
            "dynamite",
            "esel",
            "grenade _fly",
            "mingvase",
            "mingshard1",
            "molotov _fly",
            "mortar _fly",
            "granny",
            "sally_army",
            "sallyshard",
            "cow 1",
            "airstrike _fly",
            "sheepstrike _burning_fly",
            "meteor _fly",
        ]

        foreach (x; stuff) {
            local xs = x.split()
            local x1 = xs[0]
            local x2 = #xs > 1 ? xs[1] : ""
            emit_text(format(
                `
                + "s_{0}" {{
                    normal = "{0}{1}"
                    drown = "{0}_drown"
                }
                `, x1, x2))
        }

        //produce gravestones
        emit_text(`
            + "s_grave" {`);
        for (i; 0..6) {
            emit_text(format(
                `
                n{0} = "grave{0}"
                drown{0} = "grave{0}_drown"`, i));
        }
        emit_text(`}`);
    !>
++/

    //-------------------
    s_holy {
        normal = "holy_fly"
        drown = "holy_drown"
    }
    s_banana {
        normal = "banana_fly"
        drown = "banana_drown"
    }
    s_bazooka {
        normal = "bazooka_fly"
        drown = "bazooka_drown"
    }
    s_clustershard {
        normal = "clustershard"
        drown = "clustershard_drown"
    }
    s_cluster {
        normal = "cluster_fly"
        drown = "cluster_drown"
    }
    s_dynamite {
        normal = "dynamite"
        drown = "dynamite_drown"
    }
    s_esel {
        normal = "esel"
        drown = "esel_drown"
    }
    s_grenade {
        normal = "grenade_fly"
        drown = "grenade_drown"
    }
    s_mingvase {
        normal = "mingvase"
        drown = "mingvase_drown"
    }
    s_mingshard1 {
        normal = "mingshard1"
        drown = "mingshard1_drown"
    }
    s_molotov {
        normal = "molotov_fly"
        drown = "molotov_drown"
    }
    s_mortar {
        normal = "mortar_fly"
        drown = "mortar_drown"
    }
    s_granny {
        normal = "granny"
        drown = "granny_drown"
    }
    s_sally_army {
        normal = "sally_army"
        drown = "sally_army_drown"
    }
    s_sallyshard {
        normal = "sallyshard"
        drown = "sallyshard_drown"
    }
    s_cow {
        normal = "cow1"
        drown = "cow_drown"
    }
    s_airstrike {
        normal = "airstrike_fly"
        drown = "airstrike_drown"
    }
    s_sheepstrike {
        normal = "sheepstrike_burning_fly"
        drown = "sheepstrike_drown"
    }
    s_meteor {
        normal = "meteor_fly"
        drown = "meteor_drown"
    }
    s_grave {
        n0 = "grave0"
        drown0 = "grave0_drown"
        n1 = "grave1"
        drown1 = "grave1_drown"
        n2 = "grave2"
        drown2 = "grave2_drown"
        n3 = "grave3"
        drown3 = "grave3_drown"
        n4 = "grave4"
        drown4 = "grave4_drown"
        n5 = "grave5"
        drown5 = "grave5_drown"
    }
    //-------------------


    s_mbbomb {
        normal = "mbbomb_fly"
        drown = "mbbomb_drown"
    }
    s_sheep {
        normal = "sheep2"
        helmet = "sheep1" //unused?
        drown = "sheep_drown"
        super_red = "supersheep_red"
        super_blue = "supersheep_blue"
        super_blue_underwater = "supersheep_blue_underwater"
    }

    s_homing {
        inactive = "homing_inactive_fly"
        active = "homing_active_fly"
        active_underwater = "homing_active_underwater"
        drown = "homing_inactive_drown"
    }


    s_napalm {
        normal {
            type = "wwp_napalm"
            fall = "napalm_fall"
            fly = "napalm_fly"
        }
    }
}


//this defines ParticleType entries
//those will be referred by the "particle" property in sprite states
//note that these live in the resources namespace, so be careful about names
particles {
    //each entry defines a ParticleType, that gets added to the resources
    //typically, it will just act as particle emitter
    p_rocket {
        //emit 20 particles / sec
        emit_interval = "25ms-30ms"
        //proposal: enable increasing the rate depending from velocity
        //-- add 1 particle/sec to emit_rate per 10 velocity units
        //-- emit_rate_add_from_vel = "10"
        //keep emitting particles forever
        emit_count = "max"
        //on each emit, use 1 of these particles (random pick)
        //each entry defines a further ParticleType
        emit {
            //[unnamed value means referencing another particle
            // named value with sub items: define particle inline]
            //(unimplemented, just an idea; here come the sub particles)
            //(a simple alternative would be to use the "template" stuff from
            // ConfigNode)
            {
                //color = "red"
                //animation can be a value, or a list (-> random selection)
                animation = "smokepuff_white"
                wind_influence = "0"
                initial_speed = "0"
                absolute_speed = "10"
                //add to emitter pos, along emitter velocity vector
                offset = "-15"
                spread_angle = "360" //in deg
            }
        }
        //play a sound when particle is created
        //xxx better: make firing the gun trigger the sound (cf. homing missile)
        sound = "a_rocket_fire"
    }
    p_napalmsmoke {
        emit_interval = "0.8s-1.2s"
        //seconds to wait until emitting starts
        emit_delay = "0s-1s"
        emit_count = "max"
        emit {
            {
                animation { "smoke_black_size1" "smoke_black_size2" }
                gravity = "-200"
                initial_speed = "0"
                wind_influence = "0.7-1.0"
                //float effect
                bubble_x = "0.7"
                bubble_x_h = "100"
            }
        }
    }
    p_holy {
        emit_interval = "50ms"
        emit_count = "max"
        emit {
            {
                //xxx only emit on impact
                animation = "holy_particle"
                initial_speed = "0"
                absolute_speed = "50"
                wind_influence = "0"
                offset = "-0"
                spread_angle = "360"
            }
        }
        sound = "a_holy"
    }
    p_supersheep {
        emit_interval = "20ms-40ms"
        emit_count = "max"
        emit {
            {
                animation = "holy_particle"
                initial_speed = "0"
                absolute_speed = "30"
                wind_influence = "0.5"
                offset = "-20"
                spread_angle = "360"
            }
        }
        sound = "a_supersheep_release"
    }
    p_mbbomb {
        emit_interval = "100ms-150ms"
        emit_count = "max"
        emit {
            {
                animation = "mbbomb_particle"
                initial_speed = "0"
                absolute_speed = "25"
                wind_influence = "0"
                spread_angle = "360"
            }
        }
    }
    p_donkey {
        sound = "a_donkey_create"
    }
    p_meteor {
        sound = "a_armageddon"
    }
    p_rocketcharge {
        sound = "a_rocket_charge"
    }
    p_beam {
        sound = "a_beam"
    }
    p_dynamite {
        sound = "a_dynamite_fuse"
        sound_looping = "true"
    }
    p_cow {
        sound = "a_cow_release"
    }
    p_granny {
        sound = "a_granny"
        sound_looping = "true"
    }
    p_sheep {
        sound = "a_sheep"
    }
    p_projectiledrown {
        emit_interval = "20ms-40ms"
        emit_count = "max"
        emit {
            {
                animation { "bubble0" "bubble1" "bubble2" "bubble3" }
                initial_speed = "0"
                gravity = "-100"
                bubble_x = "0.5"
                bubble_x_h = "100"
                underwater = "true"
            }
        }
        sound = "a_splash"
    }
    p_waterbubble {
        animation { "bubble0" "bubble1" }
        gravity = "-100"
        bubble_x = "0.5"
        bubble_x_h = "100"
        underwater = "true"
    }
    p_spark {
        animation { "fire_particle" }
        gravity = "600"
        emit_interval = "0.2s-0.4s"
        //seconds to wait until emitting starts
        emit_delay = "0s-0.3s"
        emit_count = "4"
        emit {
            {
                animation { "smoke_black_size1" }
                gravity = "-200"
                initial_speed = "0"
                wind_influence = "0.7-1.0"
                //float effect
                bubble_x = "0.7"
                bubble_x_h = "100"
            }
        }
    }
    //a particle that just plays sound
    //maybe we could create explosion particles for each explosion size, but
    //  that would require rewriting showExplosion() (and maybe particle
    //  emitters aren't able to do everything showExplosion() would need)
    p_explosion_sound {
        //NOTE: we just don't use an animation, although we could
        //for each explosion, one of those is played (random pick)
        sound {
            "a_explosion1"
            "a_explosion2"
            "a_explosion3"
        }
    }
}

/+ proposal by d0c; outdated, but still might contain good ideas

//this section defines how a particle looks and behaves _after_ it has been emitted
particles {
    //those IDs are normally only referenced by particle emitters
    rocket_smoke {
        animation = "smokepuff_white"
        //particles always die on animation-end; use this to override
        //lifetime = "1000"
        //most particle effects are not global, e.g. there's no shared gravity value
        gravity = "0"
    }
    smoke_white_1 {
        animation = "smoke_white_size1"
        //negative -> go upwards
        gravity = "-300"
        //add a float-effect (like water labels)
        float = "10"
        //no idea what unit that is
        air_resistance = "0.5"
        //an example for a global particle effect
        wind_influence = "1.0"
    }
    fire_particle {
        animation = "fire_particle"
        gravity = "600"
        wind_influence = "1.0"
        //particles can emit other particles
        attach_emitter = "smoker_black_small"
    }
}

//this section assigns particles to emitters, and sets the starting parameters
particle_emitters {
    //emitters are normally attached to a parent graphic; IDs are referenced
    //  by the engine
    rocket {
        //"normal" -> emit particles at position of emitter
        //  (maybe more will follow, e.g. emit at skyline)
        type = "normal"
        //emitters die when all work is done, or when the parent graphic dies
        //  set lifetime to override
        //lifetime = "1000"
        //a list of emitted particles
        {
            particle = "rocket_smoke"
            count = "1"
            //emit every xx milliseconds (empty for one-time)
            interval = "200"
            //particles always start at the position forced at them by
            //  the emitter type; offset is added to that
            offset_x = "-3-3" //xxx not sure if this works, maybe need to modify RandVal
            offset_y = "-3-3"
            //starting velocity
            velocity_x = "0"
            velocity_y = "0"
            //true -> velocity is relative to parent (directed / orthogonal)
            rel_velocity = "false"
        }
    }
    explosion {
        type = "normal"
        {
            particle = "smoke_white_1"
            //emits this number once and then dies
            count = "7-10"
            offset_x = "-5-5"
            offset_y = "-5-5"
        }
        {
            particle = "fire_particle"
            count = "3-5"
            //upwards, with a little spread
            velocity_x = "-200-200"
            velocity_y = "-500"
            offset_x = "-5-5"
            offset_y = "-5-5"
        }
    }
}
+/
